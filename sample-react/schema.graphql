# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

type AmountEarnedInPeriod {
  amount: Float
  duration: Float
  endPeriodDate: String
  startPeriodDate: String
}

type AuthResponse {
  idp: String
  onBoardingCompleted: Boolean
  phoneNumber: String
  stripe: Boolean
  truevault: String
  userTypeId: Int
}

type AvailableShifts {
  backups: Int
  capacity: Int
  counselor_enrollment: CounselorEnrollment
  count: Int
  end_date: String
  id: Int
  shift_states_id: Int
  start_date: String
}

type CopyShiftErrorResponse {
  code: String!
  message: String!
  shift: CopyShiftObject!
}

type CopyShiftObject {
  capacity: Int!
  endDate: String!
  startDate: String!
}

type CopyShiftsResponse {
  copyErrors: [CopyShiftErrorResponse]!
  ids: [String]!
}

type CounselorEnrollment {
  backup: Boolean
  counselor_id: String
  id: Int
  shift_end_date: String
  shift_start_date: String
  shift_states_id: Int
  students: Int
}

type CounselorID {
  avatar_url: String
  bio: String
  first_name: String
  id: String
  last_name: String
  license_number: String
  license_state: String
  profile_document_id: String
  school: SchoolRef
}

type EmergencyServiceRef {
  id: Int
  name: String!
  phone: String!
}

type Mutation {
  addFeedback(comment: String!, helpful: Boolean!, sessionId: Int!): String
  cancelSession(details: String, reason: String!, sessionId: Int!): String
  changeSessionStatus(sessionId: Int!, statusId: Int!): String
  chatNow(description: String!, timeZone: String, topics: [Int!]!): SessionRef!
  continueOnboarding(password: String!, phone_number: String!): String
  copyShifts(fromDate: String!, timeZone: String!, toDate: String!): CopyShiftsResponse
  createAdminUser(email: String!, first_name: String!, last_name: String!): String
  createCounselorUser(email: String!, first_name: String!, last_name: String!): String
  createOrUpdateSchool(input: SchoolInput): SchoolRef
  createShift(capacity: Int!, endDate: String!, startDate: String!): Int
  deleteShift(shiftId: Int!): String
  forgotPassword(email: String!): String
  initiateTFA(phone_number: String): String
  insertCounselorEnrollment(counselorId: String, shiftStatesId: Int!, timeZone: String): Int
  insertSession(counselorId: String, date: String!, description: String!, sessionTypeId: Int!, studentId: String!, topics: [Int!]!): String
  leaveShift(counselorEnrollmentId: Int!): CounselorEnrollment
  markUserOnboarded: String
  savePaymentInformation(authorizationToken: String!): String
  scheduleSession(counselorId: String, date: String!, description: String!, topics: [Int!]!): String
  updateAdminGroupPolicy: String
  updatePassword(password: String!): String
  updateShiftCapacity(capacity: Int!, shiftId: Int!, stateId: Int): String
  updateUserEmail(newEmail: String!, userId: String!): String
  uploadAvatar(file: String!): String
  verifyTFA(code: String!): String
}

type PastNotesRef {
  date: String
  note_document_id: String
  session_id: Int!
}

type PlanRef {
  frequency: String!
  id: Int!
  name: String!
  sessions_count: Int!
}

type Query {
  availableShifts(from: String!, stateId: Int!, to: String, userId: String): [AvailableShifts]
  checkAuthorization: String
  checkChatNowAvailability(counselorId: String, timeZone: String): [String]
  checkScheduleAvailability(counselorId: String, dateFrom: String!, dateTo: String!): [String]
  datesWithCounselorsAvailables(counselorId: String, dateFrom: String!, dateTo: String!, sessionTypeId: Int): [String]
  getEarnedAmountInPeriod(endDate: String, startDate: String, timeZone: String): AmountEarnedInPeriod
  getPastNotesDocumentIds(studentId: String!): [PastNotesRef]
  getPastSessions(limit: Int, offset: Int, studentId: String): SessionPagination!
  getPreviousCounselors(studentId: String): [CounselorID]
  getSessionDetails(sessionId: Int!): SessionRef!
  getTruevaultUserAccessToken: String
  getUpcomingSession(studentId: String): SessionRef
  login(email: String!, password: String!): AuthResponse
  me: AuthResponse
  ping: String
  sessionsAvailable: SessionsAvailable
}

type SchoolRef {
  address: String!
  emergency_services: [EmergencyServiceRef!]
  enabled: Boolean!
  id: Int!
  issuer: String!
  logo: String!
  name: String!
  phone: String!
  plan: PlanRef!
  resources: String
  state: StateRef!
}

type SessionPagination {
  sessions: [SessionRef]
  total: Int
}

type SessionRef {
  chat_channel_id: String
  counselor: CounselorID!
  description: String
  end_date: String
  id: Int!
  note_document_id: String
  scheduled_end_date: String!
  scheduled_start_date: String!
  session_status_id: Int
  session_topics: [String!]!
  start_date: String
}

type SessionsAvailable {
  chat_now_consumed: Boolean
  chat_now_frequency_hours: Int
  frequency: String
  max_chat_now_sessions_count: Int
  plan_sessions_count: Int
  sessions_consumed: Int
}

type StateRef {
  abbreviation: String!
  id: Int!
  value: String!
}

"columns and relationships of \"account_status\""
type account_status {
  comment: String
  value: String!
}

"aggregated selection of \"account_status\""
type account_status_aggregate {
  aggregate: account_status_aggregate_fields
  nodes: [account_status!]!
}

"aggregate fields of \"account_status\""
type account_status_aggregate_fields {
  count(columns: [account_status_select_column!], distinct: Boolean): Int
  max: account_status_max_fields
  min: account_status_min_fields
}

"columns and relationships of \"account_status_changes\""
type account_status_changes {
  created_at: timestamptz!
  id: Int!
  status: account_status_enum!
  user_id: uuid!
}

"aggregated selection of \"account_status_changes\""
type account_status_changes_aggregate {
  aggregate: account_status_changes_aggregate_fields
  nodes: [account_status_changes!]!
}

"aggregate fields of \"account_status_changes\""
type account_status_changes_aggregate_fields {
  avg: account_status_changes_avg_fields
  count(columns: [account_status_changes_select_column!], distinct: Boolean): Int
  max: account_status_changes_max_fields
  min: account_status_changes_min_fields
  stddev: account_status_changes_stddev_fields
  stddev_pop: account_status_changes_stddev_pop_fields
  stddev_samp: account_status_changes_stddev_samp_fields
  sum: account_status_changes_sum_fields
  var_pop: account_status_changes_var_pop_fields
  var_samp: account_status_changes_var_samp_fields
  variance: account_status_changes_variance_fields
}

"aggregate avg on columns"
type account_status_changes_avg_fields {
  id: Float
}

"aggregate max on columns"
type account_status_changes_max_fields {
  created_at: timestamptz
  id: Int
  user_id: uuid
}

"aggregate min on columns"
type account_status_changes_min_fields {
  created_at: timestamptz
  id: Int
  user_id: uuid
}

"response of any mutation on the table \"account_status_changes\""
type account_status_changes_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [account_status_changes!]!
}

"aggregate stddev on columns"
type account_status_changes_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type account_status_changes_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type account_status_changes_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type account_status_changes_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type account_status_changes_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type account_status_changes_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type account_status_changes_variance_fields {
  id: Float
}

"aggregate max on columns"
type account_status_max_fields {
  comment: String
  value: String
}

"aggregate min on columns"
type account_status_min_fields {
  comment: String
  value: String
}

"response of any mutation on the table \"account_status\""
type account_status_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [account_status!]!
}

"""

this table hold the configuration data


columns and relationships of "config"
"""
type config {
  chat_now_frequency_hours: Int
  chats_vault_id: uuid!
  counselor_shift_capacity: Int!
  counslr_resources_url: String!
  counslr_website: String!
  failed_attempts_count: Int!
  id: Int!
  max_backups_per_shift: Int!
  max_schedule_weeks_threshold: Int!
  max_shift_duration_hours: Int
  max_students_per_counselor_shift: Int!
  min_shift_duration_hours: Int!
  notes_submit_hours_threshold: Int!
  notes_vault_id: uuid!
  privacy_policy_url: String!
  stripe_client_id: String!
  support_email: String!
  terms_url: String!
}

"aggregated selection of \"config\""
type config_aggregate {
  aggregate: config_aggregate_fields
  nodes: [config!]!
}

"aggregate fields of \"config\""
type config_aggregate_fields {
  avg: config_avg_fields
  count(columns: [config_select_column!], distinct: Boolean): Int
  max: config_max_fields
  min: config_min_fields
  stddev: config_stddev_fields
  stddev_pop: config_stddev_pop_fields
  stddev_samp: config_stddev_samp_fields
  sum: config_sum_fields
  var_pop: config_var_pop_fields
  var_samp: config_var_samp_fields
  variance: config_variance_fields
}

"aggregate avg on columns"
type config_avg_fields {
  chat_now_frequency_hours: Float
  counselor_shift_capacity: Float
  failed_attempts_count: Float
  id: Float
  max_backups_per_shift: Float
  max_schedule_weeks_threshold: Float
  max_shift_duration_hours: Float
  max_students_per_counselor_shift: Float
  min_shift_duration_hours: Float
  notes_submit_hours_threshold: Float
}

"aggregate max on columns"
type config_max_fields {
  chat_now_frequency_hours: Int
  chats_vault_id: uuid
  counselor_shift_capacity: Int
  counslr_resources_url: String
  counslr_website: String
  failed_attempts_count: Int
  id: Int
  max_backups_per_shift: Int
  max_schedule_weeks_threshold: Int
  max_shift_duration_hours: Int
  max_students_per_counselor_shift: Int
  min_shift_duration_hours: Int
  notes_submit_hours_threshold: Int
  notes_vault_id: uuid
  privacy_policy_url: String
  stripe_client_id: String
  support_email: String
  terms_url: String
}

"aggregate min on columns"
type config_min_fields {
  chat_now_frequency_hours: Int
  chats_vault_id: uuid
  counselor_shift_capacity: Int
  counslr_resources_url: String
  counslr_website: String
  failed_attempts_count: Int
  id: Int
  max_backups_per_shift: Int
  max_schedule_weeks_threshold: Int
  max_shift_duration_hours: Int
  max_students_per_counselor_shift: Int
  min_shift_duration_hours: Int
  notes_submit_hours_threshold: Int
  notes_vault_id: uuid
  privacy_policy_url: String
  stripe_client_id: String
  support_email: String
  terms_url: String
}

"response of any mutation on the table \"config\""
type config_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [config!]!
}

"aggregate stddev on columns"
type config_stddev_fields {
  chat_now_frequency_hours: Float
  counselor_shift_capacity: Float
  failed_attempts_count: Float
  id: Float
  max_backups_per_shift: Float
  max_schedule_weeks_threshold: Float
  max_shift_duration_hours: Float
  max_students_per_counselor_shift: Float
  min_shift_duration_hours: Float
  notes_submit_hours_threshold: Float
}

"aggregate stddev_pop on columns"
type config_stddev_pop_fields {
  chat_now_frequency_hours: Float
  counselor_shift_capacity: Float
  failed_attempts_count: Float
  id: Float
  max_backups_per_shift: Float
  max_schedule_weeks_threshold: Float
  max_shift_duration_hours: Float
  max_students_per_counselor_shift: Float
  min_shift_duration_hours: Float
  notes_submit_hours_threshold: Float
}

"aggregate stddev_samp on columns"
type config_stddev_samp_fields {
  chat_now_frequency_hours: Float
  counselor_shift_capacity: Float
  failed_attempts_count: Float
  id: Float
  max_backups_per_shift: Float
  max_schedule_weeks_threshold: Float
  max_shift_duration_hours: Float
  max_students_per_counselor_shift: Float
  min_shift_duration_hours: Float
  notes_submit_hours_threshold: Float
}

"aggregate sum on columns"
type config_sum_fields {
  chat_now_frequency_hours: Int
  counselor_shift_capacity: Int
  failed_attempts_count: Int
  id: Int
  max_backups_per_shift: Int
  max_schedule_weeks_threshold: Int
  max_shift_duration_hours: Int
  max_students_per_counselor_shift: Int
  min_shift_duration_hours: Int
  notes_submit_hours_threshold: Int
}

"aggregate var_pop on columns"
type config_var_pop_fields {
  chat_now_frequency_hours: Float
  counselor_shift_capacity: Float
  failed_attempts_count: Float
  id: Float
  max_backups_per_shift: Float
  max_schedule_weeks_threshold: Float
  max_shift_duration_hours: Float
  max_students_per_counselor_shift: Float
  min_shift_duration_hours: Float
  notes_submit_hours_threshold: Float
}

"aggregate var_samp on columns"
type config_var_samp_fields {
  chat_now_frequency_hours: Float
  counselor_shift_capacity: Float
  failed_attempts_count: Float
  id: Float
  max_backups_per_shift: Float
  max_schedule_weeks_threshold: Float
  max_shift_duration_hours: Float
  max_students_per_counselor_shift: Float
  min_shift_duration_hours: Float
  notes_submit_hours_threshold: Float
}

"aggregate variance on columns"
type config_variance_fields {
  chat_now_frequency_hours: Float
  counselor_shift_capacity: Float
  failed_attempts_count: Float
  id: Float
  max_backups_per_shift: Float
  max_schedule_weeks_threshold: Float
  max_shift_duration_hours: Float
  max_students_per_counselor_shift: Float
  min_shift_duration_hours: Float
  notes_submit_hours_threshold: Float
}

"""

this table hold the enrollment data of the counselor


columns and relationships of "counselor_enrollment"
"""
type counselor_enrollment {
  backup: Boolean!
  backup_position: Int!
  counselor_id: uuid!
  id: Int!
  "An object relationship"
  payout: payout
  "An array relationship"
  sessions(
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): [session!]!
  "An aggregated array relationship"
  sessions_aggregate(
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): session_aggregate!
  "An object relationship"
  shift: shift
  shift_id: Int
  "An array relationship"
  shift_states(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): [shift_states!]!
  "An aggregated array relationship"
  shift_states_aggregate(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): shift_states_aggregate!
  shift_states_id: Int!
  "An array relationship"
  students_enrollment(
    "distinct select on columns"
    distinct_on: [student_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [student_enrollment_order_by!],
    "filter the rows returned"
    where: student_enrollment_bool_exp
  ): [student_enrollment!]!
  "An aggregated array relationship"
  students_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [student_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [student_enrollment_order_by!],
    "filter the rows returned"
    where: student_enrollment_bool_exp
  ): student_enrollment_aggregate!
}

"aggregated selection of \"counselor_enrollment\""
type counselor_enrollment_aggregate {
  aggregate: counselor_enrollment_aggregate_fields
  nodes: [counselor_enrollment!]!
}

"aggregate fields of \"counselor_enrollment\""
type counselor_enrollment_aggregate_fields {
  avg: counselor_enrollment_avg_fields
  count(columns: [counselor_enrollment_select_column!], distinct: Boolean): Int
  max: counselor_enrollment_max_fields
  min: counselor_enrollment_min_fields
  stddev: counselor_enrollment_stddev_fields
  stddev_pop: counselor_enrollment_stddev_pop_fields
  stddev_samp: counselor_enrollment_stddev_samp_fields
  sum: counselor_enrollment_sum_fields
  var_pop: counselor_enrollment_var_pop_fields
  var_samp: counselor_enrollment_var_samp_fields
  variance: counselor_enrollment_variance_fields
}

"aggregate avg on columns"
type counselor_enrollment_avg_fields {
  backup_position: Float
  id: Float
  shift_id: Float
  shift_states_id: Float
}

"aggregate max on columns"
type counselor_enrollment_max_fields {
  backup_position: Int
  counselor_id: uuid
  id: Int
  shift_id: Int
  shift_states_id: Int
}

"aggregate min on columns"
type counselor_enrollment_min_fields {
  backup_position: Int
  counselor_id: uuid
  id: Int
  shift_id: Int
  shift_states_id: Int
}

"response of any mutation on the table \"counselor_enrollment\""
type counselor_enrollment_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [counselor_enrollment!]!
}

"aggregate stddev on columns"
type counselor_enrollment_stddev_fields {
  backup_position: Float
  id: Float
  shift_id: Float
  shift_states_id: Float
}

"aggregate stddev_pop on columns"
type counselor_enrollment_stddev_pop_fields {
  backup_position: Float
  id: Float
  shift_id: Float
  shift_states_id: Float
}

"aggregate stddev_samp on columns"
type counselor_enrollment_stddev_samp_fields {
  backup_position: Float
  id: Float
  shift_id: Float
  shift_states_id: Float
}

"aggregate sum on columns"
type counselor_enrollment_sum_fields {
  backup_position: Int
  id: Int
  shift_id: Int
  shift_states_id: Int
}

"aggregate var_pop on columns"
type counselor_enrollment_var_pop_fields {
  backup_position: Float
  id: Float
  shift_id: Float
  shift_states_id: Float
}

"aggregate var_samp on columns"
type counselor_enrollment_var_samp_fields {
  backup_position: Float
  id: Float
  shift_id: Float
  shift_states_id: Float
}

"aggregate variance on columns"
type counselor_enrollment_variance_fields {
  backup_position: Float
  id: Float
  shift_id: Float
  shift_states_id: Float
}

"""

this table hold the counselor note configuration values


columns and relationships of "counselor_note_config"
"""
type counselor_note_config {
  active: Boolean!
  "An array relationship"
  custom_notes_options(
    "distinct select on columns"
    distinct_on: [custom_note_option_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [custom_note_option_order_by!],
    "filter the rows returned"
    where: custom_note_option_bool_exp
  ): [custom_note_option!]!
  "An aggregated array relationship"
  custom_notes_options_aggregate(
    "distinct select on columns"
    distinct_on: [custom_note_option_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [custom_note_option_order_by!],
    "filter the rows returned"
    where: custom_note_option_bool_exp
  ): custom_note_option_aggregate!
  id: Int!
  key: String
  max_length: Int!
  order: Int!
  title: String!
  type: String!
}

"aggregated selection of \"counselor_note_config\""
type counselor_note_config_aggregate {
  aggregate: counselor_note_config_aggregate_fields
  nodes: [counselor_note_config!]!
}

"aggregate fields of \"counselor_note_config\""
type counselor_note_config_aggregate_fields {
  avg: counselor_note_config_avg_fields
  count(columns: [counselor_note_config_select_column!], distinct: Boolean): Int
  max: counselor_note_config_max_fields
  min: counselor_note_config_min_fields
  stddev: counselor_note_config_stddev_fields
  stddev_pop: counselor_note_config_stddev_pop_fields
  stddev_samp: counselor_note_config_stddev_samp_fields
  sum: counselor_note_config_sum_fields
  var_pop: counselor_note_config_var_pop_fields
  var_samp: counselor_note_config_var_samp_fields
  variance: counselor_note_config_variance_fields
}

"aggregate avg on columns"
type counselor_note_config_avg_fields {
  id: Float
  max_length: Float
  order: Float
}

"aggregate max on columns"
type counselor_note_config_max_fields {
  id: Int
  key: String
  max_length: Int
  order: Int
  title: String
  type: String
}

"aggregate min on columns"
type counselor_note_config_min_fields {
  id: Int
  key: String
  max_length: Int
  order: Int
  title: String
  type: String
}

"response of any mutation on the table \"counselor_note_config\""
type counselor_note_config_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [counselor_note_config!]!
}

"aggregate stddev on columns"
type counselor_note_config_stddev_fields {
  id: Float
  max_length: Float
  order: Float
}

"aggregate stddev_pop on columns"
type counselor_note_config_stddev_pop_fields {
  id: Float
  max_length: Float
  order: Float
}

"aggregate stddev_samp on columns"
type counselor_note_config_stddev_samp_fields {
  id: Float
  max_length: Float
  order: Float
}

"aggregate sum on columns"
type counselor_note_config_sum_fields {
  id: Int
  max_length: Int
  order: Int
}

"aggregate var_pop on columns"
type counselor_note_config_var_pop_fields {
  id: Float
  max_length: Float
  order: Float
}

"aggregate var_samp on columns"
type counselor_note_config_var_samp_fields {
  id: Float
  max_length: Float
  order: Float
}

"aggregate variance on columns"
type counselor_note_config_variance_fields {
  id: Float
  max_length: Float
  order: Float
}

"""

this table hold counslr request


columns and relationships of "counslr_request"
"""
type counslr_request {
  email: String!
  id: Int!
}

"aggregated selection of \"counslr_request\""
type counslr_request_aggregate {
  aggregate: counslr_request_aggregate_fields
  nodes: [counslr_request!]!
}

"aggregate fields of \"counslr_request\""
type counslr_request_aggregate_fields {
  avg: counslr_request_avg_fields
  count(columns: [counslr_request_select_column!], distinct: Boolean): Int
  max: counslr_request_max_fields
  min: counslr_request_min_fields
  stddev: counslr_request_stddev_fields
  stddev_pop: counslr_request_stddev_pop_fields
  stddev_samp: counslr_request_stddev_samp_fields
  sum: counslr_request_sum_fields
  var_pop: counslr_request_var_pop_fields
  var_samp: counslr_request_var_samp_fields
  variance: counslr_request_variance_fields
}

"aggregate avg on columns"
type counslr_request_avg_fields {
  id: Float
}

"aggregate max on columns"
type counslr_request_max_fields {
  email: String
  id: Int
}

"aggregate min on columns"
type counslr_request_min_fields {
  email: String
  id: Int
}

"response of any mutation on the table \"counslr_request\""
type counslr_request_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [counslr_request!]!
}

"aggregate stddev on columns"
type counslr_request_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type counslr_request_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type counslr_request_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type counslr_request_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type counslr_request_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type counslr_request_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type counslr_request_variance_fields {
  id: Float
}

"""

this table hold the custom note configuration


columns and relationships of "custom_note_option"
"""
type custom_note_option {
  active: Boolean!
  counselor_note_config_id: Int!
  id: Int!
  value: String!
}

"aggregated selection of \"custom_note_option\""
type custom_note_option_aggregate {
  aggregate: custom_note_option_aggregate_fields
  nodes: [custom_note_option!]!
}

"aggregate fields of \"custom_note_option\""
type custom_note_option_aggregate_fields {
  avg: custom_note_option_avg_fields
  count(columns: [custom_note_option_select_column!], distinct: Boolean): Int
  max: custom_note_option_max_fields
  min: custom_note_option_min_fields
  stddev: custom_note_option_stddev_fields
  stddev_pop: custom_note_option_stddev_pop_fields
  stddev_samp: custom_note_option_stddev_samp_fields
  sum: custom_note_option_sum_fields
  var_pop: custom_note_option_var_pop_fields
  var_samp: custom_note_option_var_samp_fields
  variance: custom_note_option_variance_fields
}

"aggregate avg on columns"
type custom_note_option_avg_fields {
  counselor_note_config_id: Float
  id: Float
}

"aggregate max on columns"
type custom_note_option_max_fields {
  counselor_note_config_id: Int
  id: Int
  value: String
}

"aggregate min on columns"
type custom_note_option_min_fields {
  counselor_note_config_id: Int
  id: Int
  value: String
}

"response of any mutation on the table \"custom_note_option\""
type custom_note_option_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [custom_note_option!]!
}

"aggregate stddev on columns"
type custom_note_option_stddev_fields {
  counselor_note_config_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type custom_note_option_stddev_pop_fields {
  counselor_note_config_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type custom_note_option_stddev_samp_fields {
  counselor_note_config_id: Float
  id: Float
}

"aggregate sum on columns"
type custom_note_option_sum_fields {
  counselor_note_config_id: Int
  id: Int
}

"aggregate var_pop on columns"
type custom_note_option_var_pop_fields {
  counselor_note_config_id: Float
  id: Float
}

"aggregate var_samp on columns"
type custom_note_option_var_samp_fields {
  counselor_note_config_id: Float
  id: Float
}

"aggregate variance on columns"
type custom_note_option_variance_fields {
  counselor_note_config_id: Float
  id: Float
}

"""

this table hold the device values


columns and relationships of "device"
"""
type device {
  created_date: timestamptz!
  id: Int!
  name: String!
  platform: String!
  token: String!
  "An object relationship"
  user: user
  user_id: uuid!
}

"aggregated selection of \"device\""
type device_aggregate {
  aggregate: device_aggregate_fields
  nodes: [device!]!
}

"aggregate fields of \"device\""
type device_aggregate_fields {
  avg: device_avg_fields
  count(columns: [device_select_column!], distinct: Boolean): Int
  max: device_max_fields
  min: device_min_fields
  stddev: device_stddev_fields
  stddev_pop: device_stddev_pop_fields
  stddev_samp: device_stddev_samp_fields
  sum: device_sum_fields
  var_pop: device_var_pop_fields
  var_samp: device_var_samp_fields
  variance: device_variance_fields
}

"aggregate avg on columns"
type device_avg_fields {
  id: Float
}

"aggregate max on columns"
type device_max_fields {
  created_date: timestamptz
  id: Int
  name: String
  platform: String
  token: String
  user_id: uuid
}

"aggregate min on columns"
type device_min_fields {
  created_date: timestamptz
  id: Int
  name: String
  platform: String
  token: String
  user_id: uuid
}

"response of any mutation on the table \"device\""
type device_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [device!]!
}

"aggregate stddev on columns"
type device_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type device_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type device_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type device_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type device_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type device_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type device_variance_fields {
  id: Float
}

"""

this table hold emergency service data


columns and relationships of "emergency_service"
"""
type emergency_service {
  id: Int!
  name: String!
  phone: String!
  "An object relationship"
  school: school
  school_id: Int!
}

"aggregated selection of \"emergency_service\""
type emergency_service_aggregate {
  aggregate: emergency_service_aggregate_fields
  nodes: [emergency_service!]!
}

"aggregate fields of \"emergency_service\""
type emergency_service_aggregate_fields {
  avg: emergency_service_avg_fields
  count(columns: [emergency_service_select_column!], distinct: Boolean): Int
  max: emergency_service_max_fields
  min: emergency_service_min_fields
  stddev: emergency_service_stddev_fields
  stddev_pop: emergency_service_stddev_pop_fields
  stddev_samp: emergency_service_stddev_samp_fields
  sum: emergency_service_sum_fields
  var_pop: emergency_service_var_pop_fields
  var_samp: emergency_service_var_samp_fields
  variance: emergency_service_variance_fields
}

"aggregate avg on columns"
type emergency_service_avg_fields {
  id: Float
  school_id: Float
}

"aggregate max on columns"
type emergency_service_max_fields {
  id: Int
  name: String
  phone: String
  school_id: Int
}

"aggregate min on columns"
type emergency_service_min_fields {
  id: Int
  name: String
  phone: String
  school_id: Int
}

"response of any mutation on the table \"emergency_service\""
type emergency_service_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [emergency_service!]!
}

"aggregate stddev on columns"
type emergency_service_stddev_fields {
  id: Float
  school_id: Float
}

"aggregate stddev_pop on columns"
type emergency_service_stddev_pop_fields {
  id: Float
  school_id: Float
}

"aggregate stddev_samp on columns"
type emergency_service_stddev_samp_fields {
  id: Float
  school_id: Float
}

"aggregate sum on columns"
type emergency_service_sum_fields {
  id: Int
  school_id: Int
}

"aggregate var_pop on columns"
type emergency_service_var_pop_fields {
  id: Float
  school_id: Float
}

"aggregate var_samp on columns"
type emergency_service_var_samp_fields {
  id: Float
  school_id: Float
}

"aggregate variance on columns"
type emergency_service_variance_fields {
  id: Float
  school_id: Float
}

"""

this table hold the ethnic value


columns and relationships of "ethnicity"
"""
type ethnicity {
  id: Int!
  value: String!
}

"aggregated selection of \"ethnicity\""
type ethnicity_aggregate {
  aggregate: ethnicity_aggregate_fields
  nodes: [ethnicity!]!
}

"aggregate fields of \"ethnicity\""
type ethnicity_aggregate_fields {
  avg: ethnicity_avg_fields
  count(columns: [ethnicity_select_column!], distinct: Boolean): Int
  max: ethnicity_max_fields
  min: ethnicity_min_fields
  stddev: ethnicity_stddev_fields
  stddev_pop: ethnicity_stddev_pop_fields
  stddev_samp: ethnicity_stddev_samp_fields
  sum: ethnicity_sum_fields
  var_pop: ethnicity_var_pop_fields
  var_samp: ethnicity_var_samp_fields
  variance: ethnicity_variance_fields
}

"aggregate avg on columns"
type ethnicity_avg_fields {
  id: Float
}

"aggregate max on columns"
type ethnicity_max_fields {
  id: Int
  value: String
}

"aggregate min on columns"
type ethnicity_min_fields {
  id: Int
  value: String
}

"response of any mutation on the table \"ethnicity\""
type ethnicity_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [ethnicity!]!
}

"aggregate stddev on columns"
type ethnicity_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type ethnicity_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type ethnicity_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type ethnicity_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type ethnicity_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type ethnicity_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type ethnicity_variance_fields {
  id: Float
}

"""

this table hold all the genders.


columns and relationships of "gender"
"""
type gender {
  id: Int!
  value: String!
}

"aggregated selection of \"gender\""
type gender_aggregate {
  aggregate: gender_aggregate_fields
  nodes: [gender!]!
}

"aggregate fields of \"gender\""
type gender_aggregate_fields {
  avg: gender_avg_fields
  count(columns: [gender_select_column!], distinct: Boolean): Int
  max: gender_max_fields
  min: gender_min_fields
  stddev: gender_stddev_fields
  stddev_pop: gender_stddev_pop_fields
  stddev_samp: gender_stddev_samp_fields
  sum: gender_sum_fields
  var_pop: gender_var_pop_fields
  var_samp: gender_var_samp_fields
  variance: gender_variance_fields
}

"aggregate avg on columns"
type gender_avg_fields {
  id: Float
}

"aggregate max on columns"
type gender_max_fields {
  id: Int
  value: String
}

"aggregate min on columns"
type gender_min_fields {
  id: Int
  value: String
}

"response of any mutation on the table \"gender\""
type gender_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [gender!]!
}

"aggregate stddev on columns"
type gender_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type gender_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type gender_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type gender_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type gender_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type gender_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type gender_variance_fields {
  id: Float
}

"""

this table hold custom auth user reference


columns and relationships of "identity"
"""
type identity {
  id: String!
  "An object relationship"
  school: school
  school_id: Int
  "An object relationship"
  user: user
}

"aggregated selection of \"identity\""
type identity_aggregate {
  aggregate: identity_aggregate_fields
  nodes: [identity!]!
}

"aggregate fields of \"identity\""
type identity_aggregate_fields {
  avg: identity_avg_fields
  count(columns: [identity_select_column!], distinct: Boolean): Int
  max: identity_max_fields
  min: identity_min_fields
  stddev: identity_stddev_fields
  stddev_pop: identity_stddev_pop_fields
  stddev_samp: identity_stddev_samp_fields
  sum: identity_sum_fields
  var_pop: identity_var_pop_fields
  var_samp: identity_var_samp_fields
  variance: identity_variance_fields
}

"aggregate avg on columns"
type identity_avg_fields {
  school_id: Float
}

"aggregate max on columns"
type identity_max_fields {
  id: String
  school_id: Int
}

"aggregate min on columns"
type identity_min_fields {
  id: String
  school_id: Int
}

"response of any mutation on the table \"identity\""
type identity_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [identity!]!
}

"aggregate stddev on columns"
type identity_stddev_fields {
  school_id: Float
}

"aggregate stddev_pop on columns"
type identity_stddev_pop_fields {
  school_id: Float
}

"aggregate stddev_samp on columns"
type identity_stddev_samp_fields {
  school_id: Float
}

"aggregate sum on columns"
type identity_sum_fields {
  school_id: Int
}

"aggregate var_pop on columns"
type identity_var_pop_fields {
  school_id: Float
}

"aggregate var_samp on columns"
type identity_var_samp_fields {
  school_id: Float
}

"aggregate variance on columns"
type identity_variance_fields {
  school_id: Float
}

"mutation root"
type mutation_root {
  addFeedback(comment: String!, helpful: Boolean!, sessionId: Int!): String
  cancelSession(details: String, reason: String!, sessionId: Int!): String
  changeSessionStatus(sessionId: Int!, statusId: Int!): String
  chatNow(description: String!, timeZone: String, topics: [Int!]!): SessionRef!
  continueOnboarding(password: String!, phone_number: String!): String
  copyShifts(fromDate: String!, timeZone: String!, toDate: String!): CopyShiftsResponse
  createAdminUser(email: String!, first_name: String!, last_name: String!): String
  createCounselorUser(email: String!, first_name: String!, last_name: String!): String
  createOrUpdateSchool(input: SchoolInput): SchoolRef
  createShift(capacity: Int!, endDate: String!, startDate: String!): Int
  deleteShift(shiftId: Int!): String
  "delete data from the table: \"account_status\""
  delete_account_status(
    "filter the rows which have to be deleted"
    where: account_status_bool_exp!
  ): account_status_mutation_response
  "delete single row from the table: \"account_status\""
  delete_account_status_by_pk(value: String!): account_status
  "delete data from the table: \"account_status_changes\""
  delete_account_status_changes(
    "filter the rows which have to be deleted"
    where: account_status_changes_bool_exp!
  ): account_status_changes_mutation_response
  "delete single row from the table: \"account_status_changes\""
  delete_account_status_changes_by_pk(id: Int!): account_status_changes
  "delete data from the table: \"config\""
  delete_config(
    "filter the rows which have to be deleted"
    where: config_bool_exp!
  ): config_mutation_response
  "delete single row from the table: \"config\""
  delete_config_by_pk(id: Int!): config
  "delete data from the table: \"counselor_enrollment\""
  delete_counselor_enrollment(
    "filter the rows which have to be deleted"
    where: counselor_enrollment_bool_exp!
  ): counselor_enrollment_mutation_response
  "delete single row from the table: \"counselor_enrollment\""
  delete_counselor_enrollment_by_pk(id: Int!): counselor_enrollment
  "delete data from the table: \"counselor_note_config\""
  delete_counselor_note_config(
    "filter the rows which have to be deleted"
    where: counselor_note_config_bool_exp!
  ): counselor_note_config_mutation_response
  "delete single row from the table: \"counselor_note_config\""
  delete_counselor_note_config_by_pk(id: Int!): counselor_note_config
  "delete data from the table: \"counslr_request\""
  delete_counslr_request(
    "filter the rows which have to be deleted"
    where: counslr_request_bool_exp!
  ): counslr_request_mutation_response
  "delete single row from the table: \"counslr_request\""
  delete_counslr_request_by_pk(id: Int!): counslr_request
  "delete data from the table: \"custom_note_option\""
  delete_custom_note_option(
    "filter the rows which have to be deleted"
    where: custom_note_option_bool_exp!
  ): custom_note_option_mutation_response
  "delete single row from the table: \"custom_note_option\""
  delete_custom_note_option_by_pk(id: Int!): custom_note_option
  "delete data from the table: \"device\""
  delete_device(
    "filter the rows which have to be deleted"
    where: device_bool_exp!
  ): device_mutation_response
  "delete single row from the table: \"device\""
  delete_device_by_pk(id: Int!): device
  "delete data from the table: \"emergency_service\""
  delete_emergency_service(
    "filter the rows which have to be deleted"
    where: emergency_service_bool_exp!
  ): emergency_service_mutation_response
  "delete single row from the table: \"emergency_service\""
  delete_emergency_service_by_pk(id: Int!): emergency_service
  "delete data from the table: \"ethnicity\""
  delete_ethnicity(
    "filter the rows which have to be deleted"
    where: ethnicity_bool_exp!
  ): ethnicity_mutation_response
  "delete single row from the table: \"ethnicity\""
  delete_ethnicity_by_pk(id: Int!): ethnicity
  "delete data from the table: \"gender\""
  delete_gender(
    "filter the rows which have to be deleted"
    where: gender_bool_exp!
  ): gender_mutation_response
  "delete single row from the table: \"gender\""
  delete_gender_by_pk(id: Int!): gender
  "delete data from the table: \"identity\""
  delete_identity(
    "filter the rows which have to be deleted"
    where: identity_bool_exp!
  ): identity_mutation_response
  "delete single row from the table: \"identity\""
  delete_identity_by_pk(id: String!): identity
  "delete data from the table: \"payment_plan\""
  delete_payment_plan(
    "filter the rows which have to be deleted"
    where: payment_plan_bool_exp!
  ): payment_plan_mutation_response
  "delete single row from the table: \"payment_plan\""
  delete_payment_plan_by_pk(id: Int!): payment_plan
  "delete data from the table: \"payout\""
  delete_payout(
    "filter the rows which have to be deleted"
    where: payout_bool_exp!
  ): payout_mutation_response
  "delete single row from the table: \"payout\""
  delete_payout_by_pk(id: Int!): payout
  "delete data from the table: \"payout_status\""
  delete_payout_status(
    "filter the rows which have to be deleted"
    where: payout_status_bool_exp!
  ): payout_status_mutation_response
  "delete single row from the table: \"payout_status\""
  delete_payout_status_by_pk(id: Int!): payout_status
  "delete data from the table: \"plan\""
  delete_plan(
    "filter the rows which have to be deleted"
    where: plan_bool_exp!
  ): plan_mutation_response
  "delete single row from the table: \"plan\""
  delete_plan_by_pk(id: Int!): plan
  "delete data from the table: \"school\""
  delete_school(
    "filter the rows which have to be deleted"
    where: school_bool_exp!
  ): school_mutation_response
  "delete single row from the table: \"school\""
  delete_school_by_pk(id: Int!): school
  "delete data from the table: \"session\""
  delete_session(
    "filter the rows which have to be deleted"
    where: session_bool_exp!
  ): session_mutation_response
  "delete single row from the table: \"session\""
  delete_session_by_pk(id: Int!): session
  "delete data from the table: \"session_cancellation\""
  delete_session_cancellation(
    "filter the rows which have to be deleted"
    where: session_cancellation_bool_exp!
  ): session_cancellation_mutation_response
  "delete single row from the table: \"session_cancellation\""
  delete_session_cancellation_by_pk(id: Int!): session_cancellation
  "delete data from the table: \"session_feedback\""
  delete_session_feedback(
    "filter the rows which have to be deleted"
    where: session_feedback_bool_exp!
  ): session_feedback_mutation_response
  "delete single row from the table: \"session_feedback\""
  delete_session_feedback_by_pk(id: Int!): session_feedback
  "delete data from the table: \"session_status\""
  delete_session_status(
    "filter the rows which have to be deleted"
    where: session_status_bool_exp!
  ): session_status_mutation_response
  "delete single row from the table: \"session_status\""
  delete_session_status_by_pk(id: Int!): session_status
  "delete data from the table: \"session_topic\""
  delete_session_topic(
    "filter the rows which have to be deleted"
    where: session_topic_bool_exp!
  ): session_topic_mutation_response
  "delete single row from the table: \"session_topic\""
  delete_session_topic_by_pk(id: Int!): session_topic
  "delete data from the table: \"session_type\""
  delete_session_type(
    "filter the rows which have to be deleted"
    where: session_type_bool_exp!
  ): session_type_mutation_response
  "delete single row from the table: \"session_type\""
  delete_session_type_by_pk(id: Int!): session_type
  "delete data from the table: \"sexuality\""
  delete_sexuality(
    "filter the rows which have to be deleted"
    where: sexuality_bool_exp!
  ): sexuality_mutation_response
  "delete single row from the table: \"sexuality\""
  delete_sexuality_by_pk(id: Int!): sexuality
  "delete data from the table: \"shift\""
  delete_shift(
    "filter the rows which have to be deleted"
    where: shift_bool_exp!
  ): shift_mutation_response
  "delete single row from the table: \"shift\""
  delete_shift_by_pk(id: Int!): shift
  "delete data from the table: \"shift_states\""
  delete_shift_states(
    "filter the rows which have to be deleted"
    where: shift_states_bool_exp!
  ): shift_states_mutation_response
  "delete single row from the table: \"shift_states\""
  delete_shift_states_by_pk(id: Int!): shift_states
  "delete data from the table: \"state\""
  delete_state(
    "filter the rows which have to be deleted"
    where: state_bool_exp!
  ): state_mutation_response
  "delete single row from the table: \"state\""
  delete_state_by_pk(id: Int!): state
  "delete data from the table: \"student_enrollment\""
  delete_student_enrollment(
    "filter the rows which have to be deleted"
    where: student_enrollment_bool_exp!
  ): student_enrollment_mutation_response
  "delete single row from the table: \"student_enrollment\""
  delete_student_enrollment_by_pk(id: Int!): student_enrollment
  "delete data from the table: \"topic\""
  delete_topic(
    "filter the rows which have to be deleted"
    where: topic_bool_exp!
  ): topic_mutation_response
  "delete single row from the table: \"topic\""
  delete_topic_by_pk(id: Int!): topic
  "delete data from the table: \"user\""
  delete_user(
    "filter the rows which have to be deleted"
    where: user_bool_exp!
  ): user_mutation_response
  "delete single row from the table: \"user\""
  delete_user_by_pk(id: uuid!): user
  "delete data from the table: \"user_type\""
  delete_user_type(
    "filter the rows which have to be deleted"
    where: user_type_bool_exp!
  ): user_type_mutation_response
  "delete single row from the table: \"user_type\""
  delete_user_type_by_pk(id: Int!): user_type
  forgotPassword(email: String!): String
  initiateTFA(phone_number: String): String
  insertCounselorEnrollment(counselorId: String, shiftStatesId: Int!, timeZone: String): Int
  insertSession(counselorId: String, date: String!, description: String!, sessionTypeId: Int!, studentId: String!, topics: [Int!]!): String
  "insert data into the table: \"account_status\""
  insert_account_status(
    "the rows to be inserted"
    objects: [account_status_insert_input!]!,
    "on conflict condition"
    on_conflict: account_status_on_conflict
  ): account_status_mutation_response
  "insert data into the table: \"account_status_changes\""
  insert_account_status_changes(
    "the rows to be inserted"
    objects: [account_status_changes_insert_input!]!,
    "on conflict condition"
    on_conflict: account_status_changes_on_conflict
  ): account_status_changes_mutation_response
  "insert a single row into the table: \"account_status_changes\""
  insert_account_status_changes_one(
    "the row to be inserted"
    object: account_status_changes_insert_input!,
    "on conflict condition"
    on_conflict: account_status_changes_on_conflict
  ): account_status_changes
  "insert a single row into the table: \"account_status\""
  insert_account_status_one(
    "the row to be inserted"
    object: account_status_insert_input!,
    "on conflict condition"
    on_conflict: account_status_on_conflict
  ): account_status
  "insert data into the table: \"config\""
  insert_config(
    "the rows to be inserted"
    objects: [config_insert_input!]!,
    "on conflict condition"
    on_conflict: config_on_conflict
  ): config_mutation_response
  "insert a single row into the table: \"config\""
  insert_config_one(
    "the row to be inserted"
    object: config_insert_input!,
    "on conflict condition"
    on_conflict: config_on_conflict
  ): config
  "insert data into the table: \"counselor_enrollment\""
  insert_counselor_enrollment(
    "the rows to be inserted"
    objects: [counselor_enrollment_insert_input!]!,
    "on conflict condition"
    on_conflict: counselor_enrollment_on_conflict
  ): counselor_enrollment_mutation_response
  "insert a single row into the table: \"counselor_enrollment\""
  insert_counselor_enrollment_one(
    "the row to be inserted"
    object: counselor_enrollment_insert_input!,
    "on conflict condition"
    on_conflict: counselor_enrollment_on_conflict
  ): counselor_enrollment
  "insert data into the table: \"counselor_note_config\""
  insert_counselor_note_config(
    "the rows to be inserted"
    objects: [counselor_note_config_insert_input!]!,
    "on conflict condition"
    on_conflict: counselor_note_config_on_conflict
  ): counselor_note_config_mutation_response
  "insert a single row into the table: \"counselor_note_config\""
  insert_counselor_note_config_one(
    "the row to be inserted"
    object: counselor_note_config_insert_input!,
    "on conflict condition"
    on_conflict: counselor_note_config_on_conflict
  ): counselor_note_config
  "insert data into the table: \"counslr_request\""
  insert_counslr_request(
    "the rows to be inserted"
    objects: [counslr_request_insert_input!]!,
    "on conflict condition"
    on_conflict: counslr_request_on_conflict
  ): counslr_request_mutation_response
  "insert a single row into the table: \"counslr_request\""
  insert_counslr_request_one(
    "the row to be inserted"
    object: counslr_request_insert_input!,
    "on conflict condition"
    on_conflict: counslr_request_on_conflict
  ): counslr_request
  "insert data into the table: \"custom_note_option\""
  insert_custom_note_option(
    "the rows to be inserted"
    objects: [custom_note_option_insert_input!]!,
    "on conflict condition"
    on_conflict: custom_note_option_on_conflict
  ): custom_note_option_mutation_response
  "insert a single row into the table: \"custom_note_option\""
  insert_custom_note_option_one(
    "the row to be inserted"
    object: custom_note_option_insert_input!,
    "on conflict condition"
    on_conflict: custom_note_option_on_conflict
  ): custom_note_option
  "insert data into the table: \"device\""
  insert_device(
    "the rows to be inserted"
    objects: [device_insert_input!]!,
    "on conflict condition"
    on_conflict: device_on_conflict
  ): device_mutation_response
  "insert a single row into the table: \"device\""
  insert_device_one(
    "the row to be inserted"
    object: device_insert_input!,
    "on conflict condition"
    on_conflict: device_on_conflict
  ): device
  "insert data into the table: \"emergency_service\""
  insert_emergency_service(
    "the rows to be inserted"
    objects: [emergency_service_insert_input!]!,
    "on conflict condition"
    on_conflict: emergency_service_on_conflict
  ): emergency_service_mutation_response
  "insert a single row into the table: \"emergency_service\""
  insert_emergency_service_one(
    "the row to be inserted"
    object: emergency_service_insert_input!,
    "on conflict condition"
    on_conflict: emergency_service_on_conflict
  ): emergency_service
  "insert data into the table: \"ethnicity\""
  insert_ethnicity(
    "the rows to be inserted"
    objects: [ethnicity_insert_input!]!,
    "on conflict condition"
    on_conflict: ethnicity_on_conflict
  ): ethnicity_mutation_response
  "insert a single row into the table: \"ethnicity\""
  insert_ethnicity_one(
    "the row to be inserted"
    object: ethnicity_insert_input!,
    "on conflict condition"
    on_conflict: ethnicity_on_conflict
  ): ethnicity
  "insert data into the table: \"gender\""
  insert_gender(
    "the rows to be inserted"
    objects: [gender_insert_input!]!,
    "on conflict condition"
    on_conflict: gender_on_conflict
  ): gender_mutation_response
  "insert a single row into the table: \"gender\""
  insert_gender_one(
    "the row to be inserted"
    object: gender_insert_input!,
    "on conflict condition"
    on_conflict: gender_on_conflict
  ): gender
  "insert data into the table: \"identity\""
  insert_identity(
    "the rows to be inserted"
    objects: [identity_insert_input!]!,
    "on conflict condition"
    on_conflict: identity_on_conflict
  ): identity_mutation_response
  "insert a single row into the table: \"identity\""
  insert_identity_one(
    "the row to be inserted"
    object: identity_insert_input!,
    "on conflict condition"
    on_conflict: identity_on_conflict
  ): identity
  "insert data into the table: \"payment_plan\""
  insert_payment_plan(
    "the rows to be inserted"
    objects: [payment_plan_insert_input!]!,
    "on conflict condition"
    on_conflict: payment_plan_on_conflict
  ): payment_plan_mutation_response
  "insert a single row into the table: \"payment_plan\""
  insert_payment_plan_one(
    "the row to be inserted"
    object: payment_plan_insert_input!,
    "on conflict condition"
    on_conflict: payment_plan_on_conflict
  ): payment_plan
  "insert data into the table: \"payout\""
  insert_payout(
    "the rows to be inserted"
    objects: [payout_insert_input!]!,
    "on conflict condition"
    on_conflict: payout_on_conflict
  ): payout_mutation_response
  "insert a single row into the table: \"payout\""
  insert_payout_one(
    "the row to be inserted"
    object: payout_insert_input!,
    "on conflict condition"
    on_conflict: payout_on_conflict
  ): payout
  "insert data into the table: \"payout_status\""
  insert_payout_status(
    "the rows to be inserted"
    objects: [payout_status_insert_input!]!,
    "on conflict condition"
    on_conflict: payout_status_on_conflict
  ): payout_status_mutation_response
  "insert a single row into the table: \"payout_status\""
  insert_payout_status_one(
    "the row to be inserted"
    object: payout_status_insert_input!,
    "on conflict condition"
    on_conflict: payout_status_on_conflict
  ): payout_status
  "insert data into the table: \"plan\""
  insert_plan(
    "the rows to be inserted"
    objects: [plan_insert_input!]!,
    "on conflict condition"
    on_conflict: plan_on_conflict
  ): plan_mutation_response
  "insert a single row into the table: \"plan\""
  insert_plan_one(
    "the row to be inserted"
    object: plan_insert_input!,
    "on conflict condition"
    on_conflict: plan_on_conflict
  ): plan
  "insert data into the table: \"school\""
  insert_school(
    "the rows to be inserted"
    objects: [school_insert_input!]!,
    "on conflict condition"
    on_conflict: school_on_conflict
  ): school_mutation_response
  "insert a single row into the table: \"school\""
  insert_school_one(
    "the row to be inserted"
    object: school_insert_input!,
    "on conflict condition"
    on_conflict: school_on_conflict
  ): school
  "insert data into the table: \"session\""
  insert_session(
    "the rows to be inserted"
    objects: [session_insert_input!]!,
    "on conflict condition"
    on_conflict: session_on_conflict
  ): session_mutation_response
  "insert data into the table: \"session_cancellation\""
  insert_session_cancellation(
    "the rows to be inserted"
    objects: [session_cancellation_insert_input!]!,
    "on conflict condition"
    on_conflict: session_cancellation_on_conflict
  ): session_cancellation_mutation_response
  "insert a single row into the table: \"session_cancellation\""
  insert_session_cancellation_one(
    "the row to be inserted"
    object: session_cancellation_insert_input!,
    "on conflict condition"
    on_conflict: session_cancellation_on_conflict
  ): session_cancellation
  "insert data into the table: \"session_feedback\""
  insert_session_feedback(
    "the rows to be inserted"
    objects: [session_feedback_insert_input!]!,
    "on conflict condition"
    on_conflict: session_feedback_on_conflict
  ): session_feedback_mutation_response
  "insert a single row into the table: \"session_feedback\""
  insert_session_feedback_one(
    "the row to be inserted"
    object: session_feedback_insert_input!,
    "on conflict condition"
    on_conflict: session_feedback_on_conflict
  ): session_feedback
  "insert a single row into the table: \"session\""
  insert_session_one(
    "the row to be inserted"
    object: session_insert_input!,
    "on conflict condition"
    on_conflict: session_on_conflict
  ): session
  "insert data into the table: \"session_status\""
  insert_session_status(
    "the rows to be inserted"
    objects: [session_status_insert_input!]!,
    "on conflict condition"
    on_conflict: session_status_on_conflict
  ): session_status_mutation_response
  "insert a single row into the table: \"session_status\""
  insert_session_status_one(
    "the row to be inserted"
    object: session_status_insert_input!,
    "on conflict condition"
    on_conflict: session_status_on_conflict
  ): session_status
  "insert data into the table: \"session_topic\""
  insert_session_topic(
    "the rows to be inserted"
    objects: [session_topic_insert_input!]!,
    "on conflict condition"
    on_conflict: session_topic_on_conflict
  ): session_topic_mutation_response
  "insert a single row into the table: \"session_topic\""
  insert_session_topic_one(
    "the row to be inserted"
    object: session_topic_insert_input!,
    "on conflict condition"
    on_conflict: session_topic_on_conflict
  ): session_topic
  "insert data into the table: \"session_type\""
  insert_session_type(
    "the rows to be inserted"
    objects: [session_type_insert_input!]!,
    "on conflict condition"
    on_conflict: session_type_on_conflict
  ): session_type_mutation_response
  "insert a single row into the table: \"session_type\""
  insert_session_type_one(
    "the row to be inserted"
    object: session_type_insert_input!,
    "on conflict condition"
    on_conflict: session_type_on_conflict
  ): session_type
  "insert data into the table: \"sexuality\""
  insert_sexuality(
    "the rows to be inserted"
    objects: [sexuality_insert_input!]!,
    "on conflict condition"
    on_conflict: sexuality_on_conflict
  ): sexuality_mutation_response
  "insert a single row into the table: \"sexuality\""
  insert_sexuality_one(
    "the row to be inserted"
    object: sexuality_insert_input!,
    "on conflict condition"
    on_conflict: sexuality_on_conflict
  ): sexuality
  "insert data into the table: \"shift\""
  insert_shift(
    "the rows to be inserted"
    objects: [shift_insert_input!]!,
    "on conflict condition"
    on_conflict: shift_on_conflict
  ): shift_mutation_response
  "insert a single row into the table: \"shift\""
  insert_shift_one(
    "the row to be inserted"
    object: shift_insert_input!,
    "on conflict condition"
    on_conflict: shift_on_conflict
  ): shift
  "insert data into the table: \"shift_states\""
  insert_shift_states(
    "the rows to be inserted"
    objects: [shift_states_insert_input!]!,
    "on conflict condition"
    on_conflict: shift_states_on_conflict
  ): shift_states_mutation_response
  "insert a single row into the table: \"shift_states\""
  insert_shift_states_one(
    "the row to be inserted"
    object: shift_states_insert_input!,
    "on conflict condition"
    on_conflict: shift_states_on_conflict
  ): shift_states
  "insert data into the table: \"state\""
  insert_state(
    "the rows to be inserted"
    objects: [state_insert_input!]!,
    "on conflict condition"
    on_conflict: state_on_conflict
  ): state_mutation_response
  "insert a single row into the table: \"state\""
  insert_state_one(
    "the row to be inserted"
    object: state_insert_input!,
    "on conflict condition"
    on_conflict: state_on_conflict
  ): state
  "insert data into the table: \"student_enrollment\""
  insert_student_enrollment(
    "the rows to be inserted"
    objects: [student_enrollment_insert_input!]!,
    "on conflict condition"
    on_conflict: student_enrollment_on_conflict
  ): student_enrollment_mutation_response
  "insert a single row into the table: \"student_enrollment\""
  insert_student_enrollment_one(
    "the row to be inserted"
    object: student_enrollment_insert_input!,
    "on conflict condition"
    on_conflict: student_enrollment_on_conflict
  ): student_enrollment
  "insert data into the table: \"topic\""
  insert_topic(
    "the rows to be inserted"
    objects: [topic_insert_input!]!,
    "on conflict condition"
    on_conflict: topic_on_conflict
  ): topic_mutation_response
  "insert a single row into the table: \"topic\""
  insert_topic_one(
    "the row to be inserted"
    object: topic_insert_input!,
    "on conflict condition"
    on_conflict: topic_on_conflict
  ): topic
  "insert data into the table: \"user\""
  insert_user(
    "the rows to be inserted"
    objects: [user_insert_input!]!,
    "on conflict condition"
    on_conflict: user_on_conflict
  ): user_mutation_response
  "insert a single row into the table: \"user\""
  insert_user_one(
    "the row to be inserted"
    object: user_insert_input!,
    "on conflict condition"
    on_conflict: user_on_conflict
  ): user
  "insert data into the table: \"user_type\""
  insert_user_type(
    "the rows to be inserted"
    objects: [user_type_insert_input!]!,
    "on conflict condition"
    on_conflict: user_type_on_conflict
  ): user_type_mutation_response
  "insert a single row into the table: \"user_type\""
  insert_user_type_one(
    "the row to be inserted"
    object: user_type_insert_input!,
    "on conflict condition"
    on_conflict: user_type_on_conflict
  ): user_type
  leaveShift(counselorEnrollmentId: Int!): CounselorEnrollment
  markUserOnboarded: String
  savePaymentInformation(authorizationToken: String!): String
  scheduleSession(counselorId: String, date: String!, description: String!, topics: [Int!]!): String
  updateAdminGroupPolicy: String
  updatePassword(password: String!): String
  updateShiftCapacity(capacity: Int!, shiftId: Int!, stateId: Int): String
  updateUserEmail(newEmail: String!, userId: String!): String
  "update data of the table: \"account_status\""
  update_account_status(
    "sets the columns of the filtered rows to the given values"
    _set: account_status_set_input,
    "filter the rows which have to be updated"
    where: account_status_bool_exp!
  ): account_status_mutation_response
  "update single row of the table: \"account_status\""
  update_account_status_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: account_status_set_input,
    pk_columns: account_status_pk_columns_input!
  ): account_status
  "update data of the table: \"account_status_changes\""
  update_account_status_changes(
    "increments the integer columns with given value of the filtered values"
    _inc: account_status_changes_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: account_status_changes_set_input,
    "filter the rows which have to be updated"
    where: account_status_changes_bool_exp!
  ): account_status_changes_mutation_response
  "update single row of the table: \"account_status_changes\""
  update_account_status_changes_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: account_status_changes_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: account_status_changes_set_input,
    pk_columns: account_status_changes_pk_columns_input!
  ): account_status_changes
  "update data of the table: \"config\""
  update_config(
    "increments the integer columns with given value of the filtered values"
    _inc: config_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: config_set_input,
    "filter the rows which have to be updated"
    where: config_bool_exp!
  ): config_mutation_response
  "update single row of the table: \"config\""
  update_config_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: config_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: config_set_input,
    pk_columns: config_pk_columns_input!
  ): config
  "update data of the table: \"counselor_enrollment\""
  update_counselor_enrollment(
    "increments the integer columns with given value of the filtered values"
    _inc: counselor_enrollment_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: counselor_enrollment_set_input,
    "filter the rows which have to be updated"
    where: counselor_enrollment_bool_exp!
  ): counselor_enrollment_mutation_response
  "update single row of the table: \"counselor_enrollment\""
  update_counselor_enrollment_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: counselor_enrollment_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: counselor_enrollment_set_input,
    pk_columns: counselor_enrollment_pk_columns_input!
  ): counselor_enrollment
  "update data of the table: \"counselor_note_config\""
  update_counselor_note_config(
    "increments the integer columns with given value of the filtered values"
    _inc: counselor_note_config_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: counselor_note_config_set_input,
    "filter the rows which have to be updated"
    where: counselor_note_config_bool_exp!
  ): counselor_note_config_mutation_response
  "update single row of the table: \"counselor_note_config\""
  update_counselor_note_config_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: counselor_note_config_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: counselor_note_config_set_input,
    pk_columns: counselor_note_config_pk_columns_input!
  ): counselor_note_config
  "update data of the table: \"counslr_request\""
  update_counslr_request(
    "increments the integer columns with given value of the filtered values"
    _inc: counslr_request_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: counslr_request_set_input,
    "filter the rows which have to be updated"
    where: counslr_request_bool_exp!
  ): counslr_request_mutation_response
  "update single row of the table: \"counslr_request\""
  update_counslr_request_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: counslr_request_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: counslr_request_set_input,
    pk_columns: counslr_request_pk_columns_input!
  ): counslr_request
  "update data of the table: \"custom_note_option\""
  update_custom_note_option(
    "increments the integer columns with given value of the filtered values"
    _inc: custom_note_option_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: custom_note_option_set_input,
    "filter the rows which have to be updated"
    where: custom_note_option_bool_exp!
  ): custom_note_option_mutation_response
  "update single row of the table: \"custom_note_option\""
  update_custom_note_option_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: custom_note_option_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: custom_note_option_set_input,
    pk_columns: custom_note_option_pk_columns_input!
  ): custom_note_option
  "update data of the table: \"device\""
  update_device(
    "increments the integer columns with given value of the filtered values"
    _inc: device_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: device_set_input,
    "filter the rows which have to be updated"
    where: device_bool_exp!
  ): device_mutation_response
  "update single row of the table: \"device\""
  update_device_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: device_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: device_set_input,
    pk_columns: device_pk_columns_input!
  ): device
  "update data of the table: \"emergency_service\""
  update_emergency_service(
    "increments the integer columns with given value of the filtered values"
    _inc: emergency_service_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: emergency_service_set_input,
    "filter the rows which have to be updated"
    where: emergency_service_bool_exp!
  ): emergency_service_mutation_response
  "update single row of the table: \"emergency_service\""
  update_emergency_service_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: emergency_service_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: emergency_service_set_input,
    pk_columns: emergency_service_pk_columns_input!
  ): emergency_service
  "update data of the table: \"ethnicity\""
  update_ethnicity(
    "increments the integer columns with given value of the filtered values"
    _inc: ethnicity_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: ethnicity_set_input,
    "filter the rows which have to be updated"
    where: ethnicity_bool_exp!
  ): ethnicity_mutation_response
  "update single row of the table: \"ethnicity\""
  update_ethnicity_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: ethnicity_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: ethnicity_set_input,
    pk_columns: ethnicity_pk_columns_input!
  ): ethnicity
  "update data of the table: \"gender\""
  update_gender(
    "increments the integer columns with given value of the filtered values"
    _inc: gender_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: gender_set_input,
    "filter the rows which have to be updated"
    where: gender_bool_exp!
  ): gender_mutation_response
  "update single row of the table: \"gender\""
  update_gender_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: gender_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: gender_set_input,
    pk_columns: gender_pk_columns_input!
  ): gender
  "update data of the table: \"identity\""
  update_identity(
    "increments the integer columns with given value of the filtered values"
    _inc: identity_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: identity_set_input,
    "filter the rows which have to be updated"
    where: identity_bool_exp!
  ): identity_mutation_response
  "update single row of the table: \"identity\""
  update_identity_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: identity_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: identity_set_input,
    pk_columns: identity_pk_columns_input!
  ): identity
  "update data of the table: \"payment_plan\""
  update_payment_plan(
    "increments the integer columns with given value of the filtered values"
    _inc: payment_plan_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: payment_plan_set_input,
    "filter the rows which have to be updated"
    where: payment_plan_bool_exp!
  ): payment_plan_mutation_response
  "update single row of the table: \"payment_plan\""
  update_payment_plan_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: payment_plan_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: payment_plan_set_input,
    pk_columns: payment_plan_pk_columns_input!
  ): payment_plan
  "update data of the table: \"payout\""
  update_payout(
    "increments the integer columns with given value of the filtered values"
    _inc: payout_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: payout_set_input,
    "filter the rows which have to be updated"
    where: payout_bool_exp!
  ): payout_mutation_response
  "update single row of the table: \"payout\""
  update_payout_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: payout_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: payout_set_input,
    pk_columns: payout_pk_columns_input!
  ): payout
  "update data of the table: \"payout_status\""
  update_payout_status(
    "increments the integer columns with given value of the filtered values"
    _inc: payout_status_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: payout_status_set_input,
    "filter the rows which have to be updated"
    where: payout_status_bool_exp!
  ): payout_status_mutation_response
  "update single row of the table: \"payout_status\""
  update_payout_status_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: payout_status_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: payout_status_set_input,
    pk_columns: payout_status_pk_columns_input!
  ): payout_status
  "update data of the table: \"plan\""
  update_plan(
    "increments the integer columns with given value of the filtered values"
    _inc: plan_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: plan_set_input,
    "filter the rows which have to be updated"
    where: plan_bool_exp!
  ): plan_mutation_response
  "update single row of the table: \"plan\""
  update_plan_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: plan_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: plan_set_input,
    pk_columns: plan_pk_columns_input!
  ): plan
  "update data of the table: \"school\""
  update_school(
    "increments the integer columns with given value of the filtered values"
    _inc: school_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: school_set_input,
    "filter the rows which have to be updated"
    where: school_bool_exp!
  ): school_mutation_response
  "update single row of the table: \"school\""
  update_school_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: school_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: school_set_input,
    pk_columns: school_pk_columns_input!
  ): school
  "update data of the table: \"session\""
  update_session(
    "increments the integer columns with given value of the filtered values"
    _inc: session_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_set_input,
    "filter the rows which have to be updated"
    where: session_bool_exp!
  ): session_mutation_response
  "update single row of the table: \"session\""
  update_session_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: session_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_set_input,
    pk_columns: session_pk_columns_input!
  ): session
  "update data of the table: \"session_cancellation\""
  update_session_cancellation(
    "increments the integer columns with given value of the filtered values"
    _inc: session_cancellation_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_cancellation_set_input,
    "filter the rows which have to be updated"
    where: session_cancellation_bool_exp!
  ): session_cancellation_mutation_response
  "update single row of the table: \"session_cancellation\""
  update_session_cancellation_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: session_cancellation_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_cancellation_set_input,
    pk_columns: session_cancellation_pk_columns_input!
  ): session_cancellation
  "update data of the table: \"session_feedback\""
  update_session_feedback(
    "increments the integer columns with given value of the filtered values"
    _inc: session_feedback_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_feedback_set_input,
    "filter the rows which have to be updated"
    where: session_feedback_bool_exp!
  ): session_feedback_mutation_response
  "update single row of the table: \"session_feedback\""
  update_session_feedback_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: session_feedback_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_feedback_set_input,
    pk_columns: session_feedback_pk_columns_input!
  ): session_feedback
  "update data of the table: \"session_status\""
  update_session_status(
    "increments the integer columns with given value of the filtered values"
    _inc: session_status_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_status_set_input,
    "filter the rows which have to be updated"
    where: session_status_bool_exp!
  ): session_status_mutation_response
  "update single row of the table: \"session_status\""
  update_session_status_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: session_status_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_status_set_input,
    pk_columns: session_status_pk_columns_input!
  ): session_status
  "update data of the table: \"session_topic\""
  update_session_topic(
    "increments the integer columns with given value of the filtered values"
    _inc: session_topic_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_topic_set_input,
    "filter the rows which have to be updated"
    where: session_topic_bool_exp!
  ): session_topic_mutation_response
  "update single row of the table: \"session_topic\""
  update_session_topic_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: session_topic_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_topic_set_input,
    pk_columns: session_topic_pk_columns_input!
  ): session_topic
  "update data of the table: \"session_type\""
  update_session_type(
    "increments the integer columns with given value of the filtered values"
    _inc: session_type_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_type_set_input,
    "filter the rows which have to be updated"
    where: session_type_bool_exp!
  ): session_type_mutation_response
  "update single row of the table: \"session_type\""
  update_session_type_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: session_type_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: session_type_set_input,
    pk_columns: session_type_pk_columns_input!
  ): session_type
  "update data of the table: \"sexuality\""
  update_sexuality(
    "increments the integer columns with given value of the filtered values"
    _inc: sexuality_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: sexuality_set_input,
    "filter the rows which have to be updated"
    where: sexuality_bool_exp!
  ): sexuality_mutation_response
  "update single row of the table: \"sexuality\""
  update_sexuality_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: sexuality_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: sexuality_set_input,
    pk_columns: sexuality_pk_columns_input!
  ): sexuality
  "update data of the table: \"shift\""
  update_shift(
    "increments the integer columns with given value of the filtered values"
    _inc: shift_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: shift_set_input,
    "filter the rows which have to be updated"
    where: shift_bool_exp!
  ): shift_mutation_response
  "update single row of the table: \"shift\""
  update_shift_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: shift_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: shift_set_input,
    pk_columns: shift_pk_columns_input!
  ): shift
  "update data of the table: \"shift_states\""
  update_shift_states(
    "increments the integer columns with given value of the filtered values"
    _inc: shift_states_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: shift_states_set_input,
    "filter the rows which have to be updated"
    where: shift_states_bool_exp!
  ): shift_states_mutation_response
  "update single row of the table: \"shift_states\""
  update_shift_states_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: shift_states_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: shift_states_set_input,
    pk_columns: shift_states_pk_columns_input!
  ): shift_states
  "update data of the table: \"state\""
  update_state(
    "increments the integer columns with given value of the filtered values"
    _inc: state_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: state_set_input,
    "filter the rows which have to be updated"
    where: state_bool_exp!
  ): state_mutation_response
  "update single row of the table: \"state\""
  update_state_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: state_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: state_set_input,
    pk_columns: state_pk_columns_input!
  ): state
  "update data of the table: \"student_enrollment\""
  update_student_enrollment(
    "increments the integer columns with given value of the filtered values"
    _inc: student_enrollment_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: student_enrollment_set_input,
    "filter the rows which have to be updated"
    where: student_enrollment_bool_exp!
  ): student_enrollment_mutation_response
  "update single row of the table: \"student_enrollment\""
  update_student_enrollment_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: student_enrollment_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: student_enrollment_set_input,
    pk_columns: student_enrollment_pk_columns_input!
  ): student_enrollment
  "update data of the table: \"topic\""
  update_topic(
    "increments the integer columns with given value of the filtered values"
    _inc: topic_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: topic_set_input,
    "filter the rows which have to be updated"
    where: topic_bool_exp!
  ): topic_mutation_response
  "update single row of the table: \"topic\""
  update_topic_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: topic_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: topic_set_input,
    pk_columns: topic_pk_columns_input!
  ): topic
  "update data of the table: \"user\""
  update_user(
    "increments the integer columns with given value of the filtered values"
    _inc: user_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: user_set_input,
    "filter the rows which have to be updated"
    where: user_bool_exp!
  ): user_mutation_response
  "update single row of the table: \"user\""
  update_user_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: user_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: user_set_input,
    pk_columns: user_pk_columns_input!
  ): user
  "update data of the table: \"user_type\""
  update_user_type(
    "increments the integer columns with given value of the filtered values"
    _inc: user_type_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: user_type_set_input,
    "filter the rows which have to be updated"
    where: user_type_bool_exp!
  ): user_type_mutation_response
  "update single row of the table: \"user_type\""
  update_user_type_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: user_type_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: user_type_set_input,
    pk_columns: user_type_pk_columns_input!
  ): user_type
  uploadAvatar(file: String!): String
  verifyTFA(code: String!): String
}

"""

this table hold the payment plan data


columns and relationships of "payment_plan"
"""
type payment_plan {
  id: Int!
  "An array relationship"
  payouts(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): [payout!]!
  "An aggregated array relationship"
  payouts_aggregate(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): payout_aggregate!
  session_hourly_rate: numeric!
  shift_hourly_rate: numeric!
  start_date: timestamptz!
}

"aggregated selection of \"payment_plan\""
type payment_plan_aggregate {
  aggregate: payment_plan_aggregate_fields
  nodes: [payment_plan!]!
}

"aggregate fields of \"payment_plan\""
type payment_plan_aggregate_fields {
  avg: payment_plan_avg_fields
  count(columns: [payment_plan_select_column!], distinct: Boolean): Int
  max: payment_plan_max_fields
  min: payment_plan_min_fields
  stddev: payment_plan_stddev_fields
  stddev_pop: payment_plan_stddev_pop_fields
  stddev_samp: payment_plan_stddev_samp_fields
  sum: payment_plan_sum_fields
  var_pop: payment_plan_var_pop_fields
  var_samp: payment_plan_var_samp_fields
  variance: payment_plan_variance_fields
}

"aggregate avg on columns"
type payment_plan_avg_fields {
  id: Float
  session_hourly_rate: Float
  shift_hourly_rate: Float
}

"aggregate max on columns"
type payment_plan_max_fields {
  id: Int
  session_hourly_rate: numeric
  shift_hourly_rate: numeric
  start_date: timestamptz
}

"aggregate min on columns"
type payment_plan_min_fields {
  id: Int
  session_hourly_rate: numeric
  shift_hourly_rate: numeric
  start_date: timestamptz
}

"response of any mutation on the table \"payment_plan\""
type payment_plan_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [payment_plan!]!
}

"aggregate stddev on columns"
type payment_plan_stddev_fields {
  id: Float
  session_hourly_rate: Float
  shift_hourly_rate: Float
}

"aggregate stddev_pop on columns"
type payment_plan_stddev_pop_fields {
  id: Float
  session_hourly_rate: Float
  shift_hourly_rate: Float
}

"aggregate stddev_samp on columns"
type payment_plan_stddev_samp_fields {
  id: Float
  session_hourly_rate: Float
  shift_hourly_rate: Float
}

"aggregate sum on columns"
type payment_plan_sum_fields {
  id: Int
  session_hourly_rate: numeric
  shift_hourly_rate: numeric
}

"aggregate var_pop on columns"
type payment_plan_var_pop_fields {
  id: Float
  session_hourly_rate: Float
  shift_hourly_rate: Float
}

"aggregate var_samp on columns"
type payment_plan_var_samp_fields {
  id: Float
  session_hourly_rate: Float
  shift_hourly_rate: Float
}

"aggregate variance on columns"
type payment_plan_variance_fields {
  id: Float
  session_hourly_rate: Float
  shift_hourly_rate: Float
}

"""

this table hold the payout data


columns and relationships of "payout"
"""
type payout {
  amount: numeric!
  "An object relationship"
  counselor_enrollment: counselor_enrollment
  counselor_enrollment_id: Int!
  date: timestamptz!
  id: Int!
  payment_plan_id: Int!
  "An array relationship"
  payments_plan(
    "distinct select on columns"
    distinct_on: [payment_plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payment_plan_order_by!],
    "filter the rows returned"
    where: payment_plan_bool_exp
  ): [payment_plan!]!
  "An aggregated array relationship"
  payments_plan_aggregate(
    "distinct select on columns"
    distinct_on: [payment_plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payment_plan_order_by!],
    "filter the rows returned"
    where: payment_plan_bool_exp
  ): payment_plan_aggregate!
  "An array relationship"
  payout_status(
    "distinct select on columns"
    distinct_on: [payout_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_status_order_by!],
    "filter the rows returned"
    where: payout_status_bool_exp
  ): [payout_status!]!
  "An aggregated array relationship"
  payout_status_aggregate(
    "distinct select on columns"
    distinct_on: [payout_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_status_order_by!],
    "filter the rows returned"
    where: payout_status_bool_exp
  ): payout_status_aggregate!
  payout_status_id: Int!
  "An object relationship"
  session: session
  session_id: Int
  transaction_id: Int
}

"aggregated selection of \"payout\""
type payout_aggregate {
  aggregate: payout_aggregate_fields
  nodes: [payout!]!
}

"aggregate fields of \"payout\""
type payout_aggregate_fields {
  avg: payout_avg_fields
  count(columns: [payout_select_column!], distinct: Boolean): Int
  max: payout_max_fields
  min: payout_min_fields
  stddev: payout_stddev_fields
  stddev_pop: payout_stddev_pop_fields
  stddev_samp: payout_stddev_samp_fields
  sum: payout_sum_fields
  var_pop: payout_var_pop_fields
  var_samp: payout_var_samp_fields
  variance: payout_variance_fields
}

"aggregate avg on columns"
type payout_avg_fields {
  amount: Float
  counselor_enrollment_id: Float
  id: Float
  payment_plan_id: Float
  payout_status_id: Float
  session_id: Float
  transaction_id: Float
}

"aggregate max on columns"
type payout_max_fields {
  amount: numeric
  counselor_enrollment_id: Int
  date: timestamptz
  id: Int
  payment_plan_id: Int
  payout_status_id: Int
  session_id: Int
  transaction_id: Int
}

"aggregate min on columns"
type payout_min_fields {
  amount: numeric
  counselor_enrollment_id: Int
  date: timestamptz
  id: Int
  payment_plan_id: Int
  payout_status_id: Int
  session_id: Int
  transaction_id: Int
}

"response of any mutation on the table \"payout\""
type payout_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [payout!]!
}

"""

this table hold status value of payout


columns and relationships of "payout_status"
"""
type payout_status {
  id: Int!
  "An array relationship"
  payouts(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): [payout!]!
  "An aggregated array relationship"
  payouts_aggregate(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): payout_aggregate!
  value: String!
}

"aggregated selection of \"payout_status\""
type payout_status_aggregate {
  aggregate: payout_status_aggregate_fields
  nodes: [payout_status!]!
}

"aggregate fields of \"payout_status\""
type payout_status_aggregate_fields {
  avg: payout_status_avg_fields
  count(columns: [payout_status_select_column!], distinct: Boolean): Int
  max: payout_status_max_fields
  min: payout_status_min_fields
  stddev: payout_status_stddev_fields
  stddev_pop: payout_status_stddev_pop_fields
  stddev_samp: payout_status_stddev_samp_fields
  sum: payout_status_sum_fields
  var_pop: payout_status_var_pop_fields
  var_samp: payout_status_var_samp_fields
  variance: payout_status_variance_fields
}

"aggregate avg on columns"
type payout_status_avg_fields {
  id: Float
}

"aggregate max on columns"
type payout_status_max_fields {
  id: Int
  value: String
}

"aggregate min on columns"
type payout_status_min_fields {
  id: Int
  value: String
}

"response of any mutation on the table \"payout_status\""
type payout_status_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [payout_status!]!
}

"aggregate stddev on columns"
type payout_status_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type payout_status_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type payout_status_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type payout_status_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type payout_status_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type payout_status_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type payout_status_variance_fields {
  id: Float
}

"aggregate stddev on columns"
type payout_stddev_fields {
  amount: Float
  counselor_enrollment_id: Float
  id: Float
  payment_plan_id: Float
  payout_status_id: Float
  session_id: Float
  transaction_id: Float
}

"aggregate stddev_pop on columns"
type payout_stddev_pop_fields {
  amount: Float
  counselor_enrollment_id: Float
  id: Float
  payment_plan_id: Float
  payout_status_id: Float
  session_id: Float
  transaction_id: Float
}

"aggregate stddev_samp on columns"
type payout_stddev_samp_fields {
  amount: Float
  counselor_enrollment_id: Float
  id: Float
  payment_plan_id: Float
  payout_status_id: Float
  session_id: Float
  transaction_id: Float
}

"aggregate sum on columns"
type payout_sum_fields {
  amount: numeric
  counselor_enrollment_id: Int
  id: Int
  payment_plan_id: Int
  payout_status_id: Int
  session_id: Int
  transaction_id: Int
}

"aggregate var_pop on columns"
type payout_var_pop_fields {
  amount: Float
  counselor_enrollment_id: Float
  id: Float
  payment_plan_id: Float
  payout_status_id: Float
  session_id: Float
  transaction_id: Float
}

"aggregate var_samp on columns"
type payout_var_samp_fields {
  amount: Float
  counselor_enrollment_id: Float
  id: Float
  payment_plan_id: Float
  payout_status_id: Float
  session_id: Float
  transaction_id: Float
}

"aggregate variance on columns"
type payout_variance_fields {
  amount: Float
  counselor_enrollment_id: Float
  id: Float
  payment_plan_id: Float
  payout_status_id: Float
  session_id: Float
  transaction_id: Float
}

"""

this table hold the plan data


columns and relationships of "plan"
"""
type plan {
  frequency: String!
  id: Int!
  name: String!
  "An array relationship"
  schools(
    "distinct select on columns"
    distinct_on: [school_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [school_order_by!],
    "filter the rows returned"
    where: school_bool_exp
  ): [school!]!
  "An aggregated array relationship"
  schools_aggregate(
    "distinct select on columns"
    distinct_on: [school_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [school_order_by!],
    "filter the rows returned"
    where: school_bool_exp
  ): school_aggregate!
  sessions_count: Int!
}

"aggregated selection of \"plan\""
type plan_aggregate {
  aggregate: plan_aggregate_fields
  nodes: [plan!]!
}

"aggregate fields of \"plan\""
type plan_aggregate_fields {
  avg: plan_avg_fields
  count(columns: [plan_select_column!], distinct: Boolean): Int
  max: plan_max_fields
  min: plan_min_fields
  stddev: plan_stddev_fields
  stddev_pop: plan_stddev_pop_fields
  stddev_samp: plan_stddev_samp_fields
  sum: plan_sum_fields
  var_pop: plan_var_pop_fields
  var_samp: plan_var_samp_fields
  variance: plan_variance_fields
}

"aggregate avg on columns"
type plan_avg_fields {
  id: Float
  sessions_count: Float
}

"aggregate max on columns"
type plan_max_fields {
  frequency: String
  id: Int
  name: String
  sessions_count: Int
}

"aggregate min on columns"
type plan_min_fields {
  frequency: String
  id: Int
  name: String
  sessions_count: Int
}

"response of any mutation on the table \"plan\""
type plan_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [plan!]!
}

"aggregate stddev on columns"
type plan_stddev_fields {
  id: Float
  sessions_count: Float
}

"aggregate stddev_pop on columns"
type plan_stddev_pop_fields {
  id: Float
  sessions_count: Float
}

"aggregate stddev_samp on columns"
type plan_stddev_samp_fields {
  id: Float
  sessions_count: Float
}

"aggregate sum on columns"
type plan_sum_fields {
  id: Int
  sessions_count: Int
}

"aggregate var_pop on columns"
type plan_var_pop_fields {
  id: Float
  sessions_count: Float
}

"aggregate var_samp on columns"
type plan_var_samp_fields {
  id: Float
  sessions_count: Float
}

"aggregate variance on columns"
type plan_variance_fields {
  id: Float
  sessions_count: Float
}

"query root"
type query_root {
  "fetch data from the table: \"account_status\""
  account_status(
    "distinct select on columns"
    distinct_on: [account_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [account_status_order_by!],
    "filter the rows returned"
    where: account_status_bool_exp
  ): [account_status!]!
  "fetch aggregated fields from the table: \"account_status\""
  account_status_aggregate(
    "distinct select on columns"
    distinct_on: [account_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [account_status_order_by!],
    "filter the rows returned"
    where: account_status_bool_exp
  ): account_status_aggregate!
  "fetch data from the table: \"account_status\" using primary key columns"
  account_status_by_pk(value: String!): account_status
  "fetch data from the table: \"account_status_changes\""
  account_status_changes(
    "distinct select on columns"
    distinct_on: [account_status_changes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [account_status_changes_order_by!],
    "filter the rows returned"
    where: account_status_changes_bool_exp
  ): [account_status_changes!]!
  "fetch aggregated fields from the table: \"account_status_changes\""
  account_status_changes_aggregate(
    "distinct select on columns"
    distinct_on: [account_status_changes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [account_status_changes_order_by!],
    "filter the rows returned"
    where: account_status_changes_bool_exp
  ): account_status_changes_aggregate!
  "fetch data from the table: \"account_status_changes\" using primary key columns"
  account_status_changes_by_pk(id: Int!): account_status_changes
  availableShifts(from: String!, stateId: Int!, to: String, userId: String): [AvailableShifts]
  checkAuthorization: String
  checkChatNowAvailability(counselorId: String, timeZone: String): [String]
  checkScheduleAvailability(counselorId: String, dateFrom: String!, dateTo: String!): [String]
  "fetch data from the table: \"config\""
  config(
    "distinct select on columns"
    distinct_on: [config_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [config_order_by!],
    "filter the rows returned"
    where: config_bool_exp
  ): [config!]!
  "fetch aggregated fields from the table: \"config\""
  config_aggregate(
    "distinct select on columns"
    distinct_on: [config_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [config_order_by!],
    "filter the rows returned"
    where: config_bool_exp
  ): config_aggregate!
  "fetch data from the table: \"config\" using primary key columns"
  config_by_pk(id: Int!): config
  "fetch data from the table: \"counselor_enrollment\""
  counselor_enrollment(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): [counselor_enrollment!]!
  "fetch aggregated fields from the table: \"counselor_enrollment\""
  counselor_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): counselor_enrollment_aggregate!
  "fetch data from the table: \"counselor_enrollment\" using primary key columns"
  counselor_enrollment_by_pk(id: Int!): counselor_enrollment
  "fetch data from the table: \"counselor_note_config\""
  counselor_note_config(
    "distinct select on columns"
    distinct_on: [counselor_note_config_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_note_config_order_by!],
    "filter the rows returned"
    where: counselor_note_config_bool_exp
  ): [counselor_note_config!]!
  "fetch aggregated fields from the table: \"counselor_note_config\""
  counselor_note_config_aggregate(
    "distinct select on columns"
    distinct_on: [counselor_note_config_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_note_config_order_by!],
    "filter the rows returned"
    where: counselor_note_config_bool_exp
  ): counselor_note_config_aggregate!
  "fetch data from the table: \"counselor_note_config\" using primary key columns"
  counselor_note_config_by_pk(id: Int!): counselor_note_config
  "fetch data from the table: \"counslr_request\""
  counslr_request(
    "distinct select on columns"
    distinct_on: [counslr_request_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counslr_request_order_by!],
    "filter the rows returned"
    where: counslr_request_bool_exp
  ): [counslr_request!]!
  "fetch aggregated fields from the table: \"counslr_request\""
  counslr_request_aggregate(
    "distinct select on columns"
    distinct_on: [counslr_request_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counslr_request_order_by!],
    "filter the rows returned"
    where: counslr_request_bool_exp
  ): counslr_request_aggregate!
  "fetch data from the table: \"counslr_request\" using primary key columns"
  counslr_request_by_pk(id: Int!): counslr_request
  "fetch data from the table: \"custom_note_option\""
  custom_note_option(
    "distinct select on columns"
    distinct_on: [custom_note_option_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [custom_note_option_order_by!],
    "filter the rows returned"
    where: custom_note_option_bool_exp
  ): [custom_note_option!]!
  "fetch aggregated fields from the table: \"custom_note_option\""
  custom_note_option_aggregate(
    "distinct select on columns"
    distinct_on: [custom_note_option_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [custom_note_option_order_by!],
    "filter the rows returned"
    where: custom_note_option_bool_exp
  ): custom_note_option_aggregate!
  "fetch data from the table: \"custom_note_option\" using primary key columns"
  custom_note_option_by_pk(id: Int!): custom_note_option
  datesWithCounselorsAvailables(counselorId: String, dateFrom: String!, dateTo: String!, sessionTypeId: Int): [String]
  "fetch data from the table: \"device\""
  device(
    "distinct select on columns"
    distinct_on: [device_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [device_order_by!],
    "filter the rows returned"
    where: device_bool_exp
  ): [device!]!
  "fetch aggregated fields from the table: \"device\""
  device_aggregate(
    "distinct select on columns"
    distinct_on: [device_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [device_order_by!],
    "filter the rows returned"
    where: device_bool_exp
  ): device_aggregate!
  "fetch data from the table: \"device\" using primary key columns"
  device_by_pk(id: Int!): device
  "fetch data from the table: \"emergency_service\""
  emergency_service(
    "distinct select on columns"
    distinct_on: [emergency_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [emergency_service_order_by!],
    "filter the rows returned"
    where: emergency_service_bool_exp
  ): [emergency_service!]!
  "fetch aggregated fields from the table: \"emergency_service\""
  emergency_service_aggregate(
    "distinct select on columns"
    distinct_on: [emergency_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [emergency_service_order_by!],
    "filter the rows returned"
    where: emergency_service_bool_exp
  ): emergency_service_aggregate!
  "fetch data from the table: \"emergency_service\" using primary key columns"
  emergency_service_by_pk(id: Int!): emergency_service
  "fetch data from the table: \"ethnicity\""
  ethnicity(
    "distinct select on columns"
    distinct_on: [ethnicity_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ethnicity_order_by!],
    "filter the rows returned"
    where: ethnicity_bool_exp
  ): [ethnicity!]!
  "fetch aggregated fields from the table: \"ethnicity\""
  ethnicity_aggregate(
    "distinct select on columns"
    distinct_on: [ethnicity_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ethnicity_order_by!],
    "filter the rows returned"
    where: ethnicity_bool_exp
  ): ethnicity_aggregate!
  "fetch data from the table: \"ethnicity\" using primary key columns"
  ethnicity_by_pk(id: Int!): ethnicity
  "fetch data from the table: \"gender\""
  gender(
    "distinct select on columns"
    distinct_on: [gender_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gender_order_by!],
    "filter the rows returned"
    where: gender_bool_exp
  ): [gender!]!
  "fetch aggregated fields from the table: \"gender\""
  gender_aggregate(
    "distinct select on columns"
    distinct_on: [gender_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gender_order_by!],
    "filter the rows returned"
    where: gender_bool_exp
  ): gender_aggregate!
  "fetch data from the table: \"gender\" using primary key columns"
  gender_by_pk(id: Int!): gender
  getEarnedAmountInPeriod(endDate: String, startDate: String, timeZone: String): AmountEarnedInPeriod
  getPastNotesDocumentIds(studentId: String!): [PastNotesRef]
  getPastSessions(limit: Int, offset: Int, studentId: String): SessionPagination!
  getPreviousCounselors(studentId: String): [CounselorID]
  getSessionDetails(sessionId: Int!): SessionRef!
  getTruevaultUserAccessToken: String
  getUpcomingSession(studentId: String): SessionRef
  "fetch data from the table: \"identity\""
  identity(
    "distinct select on columns"
    distinct_on: [identity_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [identity_order_by!],
    "filter the rows returned"
    where: identity_bool_exp
  ): [identity!]!
  "fetch aggregated fields from the table: \"identity\""
  identity_aggregate(
    "distinct select on columns"
    distinct_on: [identity_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [identity_order_by!],
    "filter the rows returned"
    where: identity_bool_exp
  ): identity_aggregate!
  "fetch data from the table: \"identity\" using primary key columns"
  identity_by_pk(id: String!): identity
  login(email: String!, password: String!): AuthResponse
  me: AuthResponse
  "fetch data from the table: \"payment_plan\""
  payment_plan(
    "distinct select on columns"
    distinct_on: [payment_plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payment_plan_order_by!],
    "filter the rows returned"
    where: payment_plan_bool_exp
  ): [payment_plan!]!
  "fetch aggregated fields from the table: \"payment_plan\""
  payment_plan_aggregate(
    "distinct select on columns"
    distinct_on: [payment_plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payment_plan_order_by!],
    "filter the rows returned"
    where: payment_plan_bool_exp
  ): payment_plan_aggregate!
  "fetch data from the table: \"payment_plan\" using primary key columns"
  payment_plan_by_pk(id: Int!): payment_plan
  "fetch data from the table: \"payout\""
  payout(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): [payout!]!
  "fetch aggregated fields from the table: \"payout\""
  payout_aggregate(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): payout_aggregate!
  "fetch data from the table: \"payout\" using primary key columns"
  payout_by_pk(id: Int!): payout
  "fetch data from the table: \"payout_status\""
  payout_status(
    "distinct select on columns"
    distinct_on: [payout_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_status_order_by!],
    "filter the rows returned"
    where: payout_status_bool_exp
  ): [payout_status!]!
  "fetch aggregated fields from the table: \"payout_status\""
  payout_status_aggregate(
    "distinct select on columns"
    distinct_on: [payout_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_status_order_by!],
    "filter the rows returned"
    where: payout_status_bool_exp
  ): payout_status_aggregate!
  "fetch data from the table: \"payout_status\" using primary key columns"
  payout_status_by_pk(id: Int!): payout_status
  ping: String
  "fetch data from the table: \"plan\""
  plan(
    "distinct select on columns"
    distinct_on: [plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [plan_order_by!],
    "filter the rows returned"
    where: plan_bool_exp
  ): [plan!]!
  "fetch aggregated fields from the table: \"plan\""
  plan_aggregate(
    "distinct select on columns"
    distinct_on: [plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [plan_order_by!],
    "filter the rows returned"
    where: plan_bool_exp
  ): plan_aggregate!
  "fetch data from the table: \"plan\" using primary key columns"
  plan_by_pk(id: Int!): plan
  "fetch data from the table: \"school\""
  school(
    "distinct select on columns"
    distinct_on: [school_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [school_order_by!],
    "filter the rows returned"
    where: school_bool_exp
  ): [school!]!
  "fetch aggregated fields from the table: \"school\""
  school_aggregate(
    "distinct select on columns"
    distinct_on: [school_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [school_order_by!],
    "filter the rows returned"
    where: school_bool_exp
  ): school_aggregate!
  "fetch data from the table: \"school\" using primary key columns"
  school_by_pk(id: Int!): school
  "fetch data from the table: \"session\""
  session(
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): [session!]!
  "fetch aggregated fields from the table: \"session\""
  session_aggregate(
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): session_aggregate!
  "fetch data from the table: \"session\" using primary key columns"
  session_by_pk(id: Int!): session
  "fetch data from the table: \"session_cancellation\""
  session_cancellation(
    "distinct select on columns"
    distinct_on: [session_cancellation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_cancellation_order_by!],
    "filter the rows returned"
    where: session_cancellation_bool_exp
  ): [session_cancellation!]!
  "fetch aggregated fields from the table: \"session_cancellation\""
  session_cancellation_aggregate(
    "distinct select on columns"
    distinct_on: [session_cancellation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_cancellation_order_by!],
    "filter the rows returned"
    where: session_cancellation_bool_exp
  ): session_cancellation_aggregate!
  "fetch data from the table: \"session_cancellation\" using primary key columns"
  session_cancellation_by_pk(id: Int!): session_cancellation
  "fetch data from the table: \"session_feedback\""
  session_feedback(
    "distinct select on columns"
    distinct_on: [session_feedback_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_feedback_order_by!],
    "filter the rows returned"
    where: session_feedback_bool_exp
  ): [session_feedback!]!
  "fetch aggregated fields from the table: \"session_feedback\""
  session_feedback_aggregate(
    "distinct select on columns"
    distinct_on: [session_feedback_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_feedback_order_by!],
    "filter the rows returned"
    where: session_feedback_bool_exp
  ): session_feedback_aggregate!
  "fetch data from the table: \"session_feedback\" using primary key columns"
  session_feedback_by_pk(id: Int!): session_feedback
  "fetch data from the table: \"session_status\""
  session_status(
    "distinct select on columns"
    distinct_on: [session_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_status_order_by!],
    "filter the rows returned"
    where: session_status_bool_exp
  ): [session_status!]!
  "fetch aggregated fields from the table: \"session_status\""
  session_status_aggregate(
    "distinct select on columns"
    distinct_on: [session_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_status_order_by!],
    "filter the rows returned"
    where: session_status_bool_exp
  ): session_status_aggregate!
  "fetch data from the table: \"session_status\" using primary key columns"
  session_status_by_pk(id: Int!): session_status
  "fetch data from the table: \"session_topic\""
  session_topic(
    "distinct select on columns"
    distinct_on: [session_topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_topic_order_by!],
    "filter the rows returned"
    where: session_topic_bool_exp
  ): [session_topic!]!
  "fetch aggregated fields from the table: \"session_topic\""
  session_topic_aggregate(
    "distinct select on columns"
    distinct_on: [session_topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_topic_order_by!],
    "filter the rows returned"
    where: session_topic_bool_exp
  ): session_topic_aggregate!
  "fetch data from the table: \"session_topic\" using primary key columns"
  session_topic_by_pk(id: Int!): session_topic
  "fetch data from the table: \"session_type\""
  session_type(
    "distinct select on columns"
    distinct_on: [session_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_type_order_by!],
    "filter the rows returned"
    where: session_type_bool_exp
  ): [session_type!]!
  "fetch aggregated fields from the table: \"session_type\""
  session_type_aggregate(
    "distinct select on columns"
    distinct_on: [session_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_type_order_by!],
    "filter the rows returned"
    where: session_type_bool_exp
  ): session_type_aggregate!
  "fetch data from the table: \"session_type\" using primary key columns"
  session_type_by_pk(id: Int!): session_type
  sessionsAvailable: SessionsAvailable
  "execute function \"sessionsOlderThan\" which returns \"session\""
  sessionsOlderThan(
    "input parameters for function \"sessionsOlderThan\""
    args: sessionsOlderThan_args!,
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): [session!]!
  "execute function \"sessionsOlderThan\" and query aggregates on result of table type \"session\""
  sessionsOlderThan_aggregate(
    "input parameters for function \"sessionsOlderThan\""
    args: sessionsOlderThan_args!,
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): session_aggregate!
  "fetch data from the table: \"sexuality\""
  sexuality(
    "distinct select on columns"
    distinct_on: [sexuality_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sexuality_order_by!],
    "filter the rows returned"
    where: sexuality_bool_exp
  ): [sexuality!]!
  "fetch aggregated fields from the table: \"sexuality\""
  sexuality_aggregate(
    "distinct select on columns"
    distinct_on: [sexuality_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sexuality_order_by!],
    "filter the rows returned"
    where: sexuality_bool_exp
  ): sexuality_aggregate!
  "fetch data from the table: \"sexuality\" using primary key columns"
  sexuality_by_pk(id: Int!): sexuality
  "fetch data from the table: \"shift\""
  shift(
    "distinct select on columns"
    distinct_on: [shift_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_order_by!],
    "filter the rows returned"
    where: shift_bool_exp
  ): [shift!]!
  "fetch aggregated fields from the table: \"shift\""
  shift_aggregate(
    "distinct select on columns"
    distinct_on: [shift_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_order_by!],
    "filter the rows returned"
    where: shift_bool_exp
  ): shift_aggregate!
  "fetch data from the table: \"shift\" using primary key columns"
  shift_by_pk(id: Int!): shift
  "fetch data from the table: \"shift_states\""
  shift_states(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): [shift_states!]!
  "fetch aggregated fields from the table: \"shift_states\""
  shift_states_aggregate(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): shift_states_aggregate!
  "fetch data from the table: \"shift_states\" using primary key columns"
  shift_states_by_pk(id: Int!): shift_states
  "fetch data from the table: \"state\""
  state(
    "distinct select on columns"
    distinct_on: [state_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [state_order_by!],
    "filter the rows returned"
    where: state_bool_exp
  ): [state!]!
  "fetch aggregated fields from the table: \"state\""
  state_aggregate(
    "distinct select on columns"
    distinct_on: [state_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [state_order_by!],
    "filter the rows returned"
    where: state_bool_exp
  ): state_aggregate!
  "fetch data from the table: \"state\" using primary key columns"
  state_by_pk(id: Int!): state
  "fetch data from the table: \"student_enrollment\""
  student_enrollment(
    "distinct select on columns"
    distinct_on: [student_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [student_enrollment_order_by!],
    "filter the rows returned"
    where: student_enrollment_bool_exp
  ): [student_enrollment!]!
  "fetch aggregated fields from the table: \"student_enrollment\""
  student_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [student_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [student_enrollment_order_by!],
    "filter the rows returned"
    where: student_enrollment_bool_exp
  ): student_enrollment_aggregate!
  "fetch data from the table: \"student_enrollment\" using primary key columns"
  student_enrollment_by_pk(id: Int!): student_enrollment
  "fetch data from the table: \"topic\""
  topic(
    "distinct select on columns"
    distinct_on: [topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [topic_order_by!],
    "filter the rows returned"
    where: topic_bool_exp
  ): [topic!]!
  "fetch aggregated fields from the table: \"topic\""
  topic_aggregate(
    "distinct select on columns"
    distinct_on: [topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [topic_order_by!],
    "filter the rows returned"
    where: topic_bool_exp
  ): topic_aggregate!
  "fetch data from the table: \"topic\" using primary key columns"
  topic_by_pk(id: Int!): topic
  "fetch data from the table: \"user\""
  user(
    "distinct select on columns"
    distinct_on: [user_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_order_by!],
    "filter the rows returned"
    where: user_bool_exp
  ): [user!]!
  "fetch aggregated fields from the table: \"user\""
  user_aggregate(
    "distinct select on columns"
    distinct_on: [user_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_order_by!],
    "filter the rows returned"
    where: user_bool_exp
  ): user_aggregate!
  "fetch data from the table: \"user\" using primary key columns"
  user_by_pk(id: uuid!): user
  "fetch data from the table: \"user_type\""
  user_type(
    "distinct select on columns"
    distinct_on: [user_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_type_order_by!],
    "filter the rows returned"
    where: user_type_bool_exp
  ): [user_type!]!
  "fetch aggregated fields from the table: \"user_type\""
  user_type_aggregate(
    "distinct select on columns"
    distinct_on: [user_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_type_order_by!],
    "filter the rows returned"
    where: user_type_bool_exp
  ): user_type_aggregate!
  "fetch data from the table: \"user_type\" using primary key columns"
  user_type_by_pk(id: Int!): user_type
}

"""

this table hold school data


columns and relationships of "school"
"""
type school {
  address: String!
  "An array relationship"
  emergency_services(
    "distinct select on columns"
    distinct_on: [emergency_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [emergency_service_order_by!],
    "filter the rows returned"
    where: emergency_service_bool_exp
  ): [emergency_service!]!
  "An aggregated array relationship"
  emergency_services_aggregate(
    "distinct select on columns"
    distinct_on: [emergency_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [emergency_service_order_by!],
    "filter the rows returned"
    where: emergency_service_bool_exp
  ): emergency_service_aggregate!
  enabled: Boolean
  id: Int!
  issuer: String!
  logo: String!
  name: String!
  phone: String!
  "An object relationship"
  plan: plan
  plan_id: Int!
  resources: String!
  "An array relationship"
  school_users(
    "distinct select on columns"
    distinct_on: [user_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_order_by!],
    "filter the rows returned"
    where: user_bool_exp
  ): [user!]!
  "An aggregated array relationship"
  school_users_aggregate(
    "distinct select on columns"
    distinct_on: [user_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_order_by!],
    "filter the rows returned"
    where: user_bool_exp
  ): user_aggregate!
  "An object relationship"
  state: state
  state_id: Int!
}

"aggregated selection of \"school\""
type school_aggregate {
  aggregate: school_aggregate_fields
  nodes: [school!]!
}

"aggregate fields of \"school\""
type school_aggregate_fields {
  avg: school_avg_fields
  count(columns: [school_select_column!], distinct: Boolean): Int
  max: school_max_fields
  min: school_min_fields
  stddev: school_stddev_fields
  stddev_pop: school_stddev_pop_fields
  stddev_samp: school_stddev_samp_fields
  sum: school_sum_fields
  var_pop: school_var_pop_fields
  var_samp: school_var_samp_fields
  variance: school_variance_fields
}

"aggregate avg on columns"
type school_avg_fields {
  id: Float
  plan_id: Float
  state_id: Float
}

"aggregate max on columns"
type school_max_fields {
  address: String
  id: Int
  issuer: String
  logo: String
  name: String
  phone: String
  plan_id: Int
  resources: String
  state_id: Int
}

"aggregate min on columns"
type school_min_fields {
  address: String
  id: Int
  issuer: String
  logo: String
  name: String
  phone: String
  plan_id: Int
  resources: String
  state_id: Int
}

"response of any mutation on the table \"school\""
type school_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [school!]!
}

"aggregate stddev on columns"
type school_stddev_fields {
  id: Float
  plan_id: Float
  state_id: Float
}

"aggregate stddev_pop on columns"
type school_stddev_pop_fields {
  id: Float
  plan_id: Float
  state_id: Float
}

"aggregate stddev_samp on columns"
type school_stddev_samp_fields {
  id: Float
  plan_id: Float
  state_id: Float
}

"aggregate sum on columns"
type school_sum_fields {
  id: Int
  plan_id: Int
  state_id: Int
}

"aggregate var_pop on columns"
type school_var_pop_fields {
  id: Float
  plan_id: Float
  state_id: Float
}

"aggregate var_samp on columns"
type school_var_samp_fields {
  id: Float
  plan_id: Float
  state_id: Float
}

"aggregate variance on columns"
type school_variance_fields {
  id: Float
  plan_id: Float
  state_id: Float
}

"""

this table hold the session data


columns and relationships of "session"
"""
type session {
  "An object relationship"
  cancellation: session_cancellation
  chat_channel_id: String
  chat_document_id: uuid
  cleanup_session: Boolean
  "An object relationship"
  counselor: user
  "An object relationship"
  counselor_enrollment: counselor_enrollment
  counselor_enrollment_id: Int!
  counselor_id: uuid!
  description: String!
  end_date: timestamptz
  id: Int!
  note_document_id: uuid
  "An array relationship"
  payouts(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): [payout!]!
  "An aggregated array relationship"
  payouts_aggregate(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): payout_aggregate!
  scheduled_end_date: timestamptz!
  scheduled_start_date: timestamptz!
  "An object relationship"
  session_feedback: session_feedback
  session_reminder_1m: Boolean!
  session_reminder_30m: Boolean!
  "An object relationship"
  session_status: session_status
  session_status_id: Int!
  "An array relationship"
  session_topics(
    "distinct select on columns"
    distinct_on: [session_topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_topic_order_by!],
    "filter the rows returned"
    where: session_topic_bool_exp
  ): [session_topic!]!
  "An aggregated array relationship"
  session_topics_aggregate(
    "distinct select on columns"
    distinct_on: [session_topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_topic_order_by!],
    "filter the rows returned"
    where: session_topic_bool_exp
  ): session_topic_aggregate!
  "An object relationship"
  session_type: session_type
  session_type_id: Int!
  start_date: timestamptz
  "An object relationship"
  student: user
  "An object relationship"
  student_enrollment: student_enrollment
  student_enrollment_id: Int!
  student_id: uuid!
}

"aggregated selection of \"session\""
type session_aggregate {
  aggregate: session_aggregate_fields
  nodes: [session!]!
}

"aggregate fields of \"session\""
type session_aggregate_fields {
  avg: session_avg_fields
  count(columns: [session_select_column!], distinct: Boolean): Int
  max: session_max_fields
  min: session_min_fields
  stddev: session_stddev_fields
  stddev_pop: session_stddev_pop_fields
  stddev_samp: session_stddev_samp_fields
  sum: session_sum_fields
  var_pop: session_var_pop_fields
  var_samp: session_var_samp_fields
  variance: session_variance_fields
}

"aggregate avg on columns"
type session_avg_fields {
  counselor_enrollment_id: Float
  id: Float
  session_status_id: Float
  session_type_id: Float
  student_enrollment_id: Float
}

"""

this table hold the cancelation data


columns and relationships of "session_cancellation"
"""
type session_cancellation {
  cancellation_date_time: timestamptz!
  cancellation_extra_details: String!
  cancellation_reason: String!
  id: Int!
  "An object relationship"
  session: session
  session_id: Int!
}

"aggregated selection of \"session_cancellation\""
type session_cancellation_aggregate {
  aggregate: session_cancellation_aggregate_fields
  nodes: [session_cancellation!]!
}

"aggregate fields of \"session_cancellation\""
type session_cancellation_aggregate_fields {
  avg: session_cancellation_avg_fields
  count(columns: [session_cancellation_select_column!], distinct: Boolean): Int
  max: session_cancellation_max_fields
  min: session_cancellation_min_fields
  stddev: session_cancellation_stddev_fields
  stddev_pop: session_cancellation_stddev_pop_fields
  stddev_samp: session_cancellation_stddev_samp_fields
  sum: session_cancellation_sum_fields
  var_pop: session_cancellation_var_pop_fields
  var_samp: session_cancellation_var_samp_fields
  variance: session_cancellation_variance_fields
}

"aggregate avg on columns"
type session_cancellation_avg_fields {
  id: Float
  session_id: Float
}

"aggregate max on columns"
type session_cancellation_max_fields {
  cancellation_date_time: timestamptz
  cancellation_extra_details: String
  cancellation_reason: String
  id: Int
  session_id: Int
}

"aggregate min on columns"
type session_cancellation_min_fields {
  cancellation_date_time: timestamptz
  cancellation_extra_details: String
  cancellation_reason: String
  id: Int
  session_id: Int
}

"response of any mutation on the table \"session_cancellation\""
type session_cancellation_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [session_cancellation!]!
}

"aggregate stddev on columns"
type session_cancellation_stddev_fields {
  id: Float
  session_id: Float
}

"aggregate stddev_pop on columns"
type session_cancellation_stddev_pop_fields {
  id: Float
  session_id: Float
}

"aggregate stddev_samp on columns"
type session_cancellation_stddev_samp_fields {
  id: Float
  session_id: Float
}

"aggregate sum on columns"
type session_cancellation_sum_fields {
  id: Int
  session_id: Int
}

"aggregate var_pop on columns"
type session_cancellation_var_pop_fields {
  id: Float
  session_id: Float
}

"aggregate var_samp on columns"
type session_cancellation_var_samp_fields {
  id: Float
  session_id: Float
}

"aggregate variance on columns"
type session_cancellation_variance_fields {
  id: Float
  session_id: Float
}

"""

this table hold the session feedback values


columns and relationships of "session_feedback"
"""
type session_feedback {
  comment: String!
  helpful: Boolean!
  id: Int!
  "An object relationship"
  session: session
  session_id: Int!
}

"aggregated selection of \"session_feedback\""
type session_feedback_aggregate {
  aggregate: session_feedback_aggregate_fields
  nodes: [session_feedback!]!
}

"aggregate fields of \"session_feedback\""
type session_feedback_aggregate_fields {
  avg: session_feedback_avg_fields
  count(columns: [session_feedback_select_column!], distinct: Boolean): Int
  max: session_feedback_max_fields
  min: session_feedback_min_fields
  stddev: session_feedback_stddev_fields
  stddev_pop: session_feedback_stddev_pop_fields
  stddev_samp: session_feedback_stddev_samp_fields
  sum: session_feedback_sum_fields
  var_pop: session_feedback_var_pop_fields
  var_samp: session_feedback_var_samp_fields
  variance: session_feedback_variance_fields
}

"aggregate avg on columns"
type session_feedback_avg_fields {
  id: Float
  session_id: Float
}

"aggregate max on columns"
type session_feedback_max_fields {
  comment: String
  id: Int
  session_id: Int
}

"aggregate min on columns"
type session_feedback_min_fields {
  comment: String
  id: Int
  session_id: Int
}

"response of any mutation on the table \"session_feedback\""
type session_feedback_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [session_feedback!]!
}

"aggregate stddev on columns"
type session_feedback_stddev_fields {
  id: Float
  session_id: Float
}

"aggregate stddev_pop on columns"
type session_feedback_stddev_pop_fields {
  id: Float
  session_id: Float
}

"aggregate stddev_samp on columns"
type session_feedback_stddev_samp_fields {
  id: Float
  session_id: Float
}

"aggregate sum on columns"
type session_feedback_sum_fields {
  id: Int
  session_id: Int
}

"aggregate var_pop on columns"
type session_feedback_var_pop_fields {
  id: Float
  session_id: Float
}

"aggregate var_samp on columns"
type session_feedback_var_samp_fields {
  id: Float
  session_id: Float
}

"aggregate variance on columns"
type session_feedback_variance_fields {
  id: Float
  session_id: Float
}

"aggregate max on columns"
type session_max_fields {
  chat_channel_id: String
  chat_document_id: uuid
  counselor_enrollment_id: Int
  counselor_id: uuid
  description: String
  end_date: timestamptz
  id: Int
  note_document_id: uuid
  scheduled_end_date: timestamptz
  scheduled_start_date: timestamptz
  session_status_id: Int
  session_type_id: Int
  start_date: timestamptz
  student_enrollment_id: Int
  student_id: uuid
}

"aggregate min on columns"
type session_min_fields {
  chat_channel_id: String
  chat_document_id: uuid
  counselor_enrollment_id: Int
  counselor_id: uuid
  description: String
  end_date: timestamptz
  id: Int
  note_document_id: uuid
  scheduled_end_date: timestamptz
  scheduled_start_date: timestamptz
  session_status_id: Int
  session_type_id: Int
  start_date: timestamptz
  student_enrollment_id: Int
  student_id: uuid
}

"response of any mutation on the table \"session\""
type session_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [session!]!
}

"""

this table hold the session status


columns and relationships of "session_status"
"""
type session_status {
  id: Int!
  "An object relationship"
  session: session
  value: String!
}

"aggregated selection of \"session_status\""
type session_status_aggregate {
  aggregate: session_status_aggregate_fields
  nodes: [session_status!]!
}

"aggregate fields of \"session_status\""
type session_status_aggregate_fields {
  avg: session_status_avg_fields
  count(columns: [session_status_select_column!], distinct: Boolean): Int
  max: session_status_max_fields
  min: session_status_min_fields
  stddev: session_status_stddev_fields
  stddev_pop: session_status_stddev_pop_fields
  stddev_samp: session_status_stddev_samp_fields
  sum: session_status_sum_fields
  var_pop: session_status_var_pop_fields
  var_samp: session_status_var_samp_fields
  variance: session_status_variance_fields
}

"aggregate avg on columns"
type session_status_avg_fields {
  id: Float
}

"aggregate max on columns"
type session_status_max_fields {
  id: Int
  value: String
}

"aggregate min on columns"
type session_status_min_fields {
  id: Int
  value: String
}

"response of any mutation on the table \"session_status\""
type session_status_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [session_status!]!
}

"aggregate stddev on columns"
type session_status_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type session_status_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type session_status_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type session_status_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type session_status_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type session_status_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type session_status_variance_fields {
  id: Float
}

"aggregate stddev on columns"
type session_stddev_fields {
  counselor_enrollment_id: Float
  id: Float
  session_status_id: Float
  session_type_id: Float
  student_enrollment_id: Float
}

"aggregate stddev_pop on columns"
type session_stddev_pop_fields {
  counselor_enrollment_id: Float
  id: Float
  session_status_id: Float
  session_type_id: Float
  student_enrollment_id: Float
}

"aggregate stddev_samp on columns"
type session_stddev_samp_fields {
  counselor_enrollment_id: Float
  id: Float
  session_status_id: Float
  session_type_id: Float
  student_enrollment_id: Float
}

"aggregate sum on columns"
type session_sum_fields {
  counselor_enrollment_id: Int
  id: Int
  session_status_id: Int
  session_type_id: Int
  student_enrollment_id: Int
}

"""

this table hold the session topic


columns and relationships of "session_topic"
"""
type session_topic {
  id: Int!
  "An object relationship"
  session: session
  session_id: Int!
  "An object relationship"
  topic: topic
  topic_id: Int!
}

"aggregated selection of \"session_topic\""
type session_topic_aggregate {
  aggregate: session_topic_aggregate_fields
  nodes: [session_topic!]!
}

"aggregate fields of \"session_topic\""
type session_topic_aggregate_fields {
  avg: session_topic_avg_fields
  count(columns: [session_topic_select_column!], distinct: Boolean): Int
  max: session_topic_max_fields
  min: session_topic_min_fields
  stddev: session_topic_stddev_fields
  stddev_pop: session_topic_stddev_pop_fields
  stddev_samp: session_topic_stddev_samp_fields
  sum: session_topic_sum_fields
  var_pop: session_topic_var_pop_fields
  var_samp: session_topic_var_samp_fields
  variance: session_topic_variance_fields
}

"aggregate avg on columns"
type session_topic_avg_fields {
  id: Float
  session_id: Float
  topic_id: Float
}

"aggregate max on columns"
type session_topic_max_fields {
  id: Int
  session_id: Int
  topic_id: Int
}

"aggregate min on columns"
type session_topic_min_fields {
  id: Int
  session_id: Int
  topic_id: Int
}

"response of any mutation on the table \"session_topic\""
type session_topic_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [session_topic!]!
}

"aggregate stddev on columns"
type session_topic_stddev_fields {
  id: Float
  session_id: Float
  topic_id: Float
}

"aggregate stddev_pop on columns"
type session_topic_stddev_pop_fields {
  id: Float
  session_id: Float
  topic_id: Float
}

"aggregate stddev_samp on columns"
type session_topic_stddev_samp_fields {
  id: Float
  session_id: Float
  topic_id: Float
}

"aggregate sum on columns"
type session_topic_sum_fields {
  id: Int
  session_id: Int
  topic_id: Int
}

"aggregate var_pop on columns"
type session_topic_var_pop_fields {
  id: Float
  session_id: Float
  topic_id: Float
}

"aggregate var_samp on columns"
type session_topic_var_samp_fields {
  id: Float
  session_id: Float
  topic_id: Float
}

"aggregate variance on columns"
type session_topic_variance_fields {
  id: Float
  session_id: Float
  topic_id: Float
}

"""

Holds types of session


columns and relationships of "session_type"
"""
type session_type {
  id: Int!
  value: String!
}

"aggregated selection of \"session_type\""
type session_type_aggregate {
  aggregate: session_type_aggregate_fields
  nodes: [session_type!]!
}

"aggregate fields of \"session_type\""
type session_type_aggregate_fields {
  avg: session_type_avg_fields
  count(columns: [session_type_select_column!], distinct: Boolean): Int
  max: session_type_max_fields
  min: session_type_min_fields
  stddev: session_type_stddev_fields
  stddev_pop: session_type_stddev_pop_fields
  stddev_samp: session_type_stddev_samp_fields
  sum: session_type_sum_fields
  var_pop: session_type_var_pop_fields
  var_samp: session_type_var_samp_fields
  variance: session_type_variance_fields
}

"aggregate avg on columns"
type session_type_avg_fields {
  id: Float
}

"aggregate max on columns"
type session_type_max_fields {
  id: Int
  value: String
}

"aggregate min on columns"
type session_type_min_fields {
  id: Int
  value: String
}

"response of any mutation on the table \"session_type\""
type session_type_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [session_type!]!
}

"aggregate stddev on columns"
type session_type_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type session_type_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type session_type_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type session_type_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type session_type_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type session_type_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type session_type_variance_fields {
  id: Float
}

"aggregate var_pop on columns"
type session_var_pop_fields {
  counselor_enrollment_id: Float
  id: Float
  session_status_id: Float
  session_type_id: Float
  student_enrollment_id: Float
}

"aggregate var_samp on columns"
type session_var_samp_fields {
  counselor_enrollment_id: Float
  id: Float
  session_status_id: Float
  session_type_id: Float
  student_enrollment_id: Float
}

"aggregate variance on columns"
type session_variance_fields {
  counselor_enrollment_id: Float
  id: Float
  session_status_id: Float
  session_type_id: Float
  student_enrollment_id: Float
}

"""

this table hold the sexuality value for user


columns and relationships of "sexuality"
"""
type sexuality {
  id: Int!
  value: String!
}

"aggregated selection of \"sexuality\""
type sexuality_aggregate {
  aggregate: sexuality_aggregate_fields
  nodes: [sexuality!]!
}

"aggregate fields of \"sexuality\""
type sexuality_aggregate_fields {
  avg: sexuality_avg_fields
  count(columns: [sexuality_select_column!], distinct: Boolean): Int
  max: sexuality_max_fields
  min: sexuality_min_fields
  stddev: sexuality_stddev_fields
  stddev_pop: sexuality_stddev_pop_fields
  stddev_samp: sexuality_stddev_samp_fields
  sum: sexuality_sum_fields
  var_pop: sexuality_var_pop_fields
  var_samp: sexuality_var_samp_fields
  variance: sexuality_variance_fields
}

"aggregate avg on columns"
type sexuality_avg_fields {
  id: Float
}

"aggregate max on columns"
type sexuality_max_fields {
  id: Int
  value: String
}

"aggregate min on columns"
type sexuality_min_fields {
  id: Int
  value: String
}

"response of any mutation on the table \"sexuality\""
type sexuality_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [sexuality!]!
}

"aggregate stddev on columns"
type sexuality_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type sexuality_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type sexuality_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type sexuality_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type sexuality_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type sexuality_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type sexuality_variance_fields {
  id: Float
}

"""

this table hold shift date data


columns and relationships of "shift"
"""
type shift {
  admin_id: uuid!
  capacity: Int
  "An array relationship"
  counselor_enrollment(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): [counselor_enrollment!]!
  "An aggregated array relationship"
  counselor_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): counselor_enrollment_aggregate!
  created_date: timestamptz!
  end_date: timestamptz!
  id: Int!
  "An array relationship"
  shift_states(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): [shift_states!]!
  "An aggregated array relationship"
  shift_states_aggregate(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): shift_states_aggregate!
  start_date: timestamptz!
  state_id: Int
}

"aggregated selection of \"shift\""
type shift_aggregate {
  aggregate: shift_aggregate_fields
  nodes: [shift!]!
}

"aggregate fields of \"shift\""
type shift_aggregate_fields {
  avg: shift_avg_fields
  count(columns: [shift_select_column!], distinct: Boolean): Int
  max: shift_max_fields
  min: shift_min_fields
  stddev: shift_stddev_fields
  stddev_pop: shift_stddev_pop_fields
  stddev_samp: shift_stddev_samp_fields
  sum: shift_sum_fields
  var_pop: shift_var_pop_fields
  var_samp: shift_var_samp_fields
  variance: shift_variance_fields
}

"aggregate avg on columns"
type shift_avg_fields {
  capacity: Float
  id: Float
  state_id: Float
}

"aggregate max on columns"
type shift_max_fields {
  admin_id: uuid
  capacity: Int
  created_date: timestamptz
  end_date: timestamptz
  id: Int
  start_date: timestamptz
  state_id: Int
}

"aggregate min on columns"
type shift_min_fields {
  admin_id: uuid
  capacity: Int
  created_date: timestamptz
  end_date: timestamptz
  id: Int
  start_date: timestamptz
  state_id: Int
}

"response of any mutation on the table \"shift\""
type shift_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [shift!]!
}

"""

this table hold the state and capacity of each shift


columns and relationships of "shift_states"
"""
type shift_states {
  capacity: numeric!
  "An array relationship"
  counselor_enrollment(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): [counselor_enrollment!]!
  "An aggregated array relationship"
  counselor_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): counselor_enrollment_aggregate!
  id: Int!
  "An object relationship"
  shift: shift
  shift_id: Int!
  "An object relationship"
  state: state
  state_id: Int!
}

"aggregated selection of \"shift_states\""
type shift_states_aggregate {
  aggregate: shift_states_aggregate_fields
  nodes: [shift_states!]!
}

"aggregate fields of \"shift_states\""
type shift_states_aggregate_fields {
  avg: shift_states_avg_fields
  count(columns: [shift_states_select_column!], distinct: Boolean): Int
  max: shift_states_max_fields
  min: shift_states_min_fields
  stddev: shift_states_stddev_fields
  stddev_pop: shift_states_stddev_pop_fields
  stddev_samp: shift_states_stddev_samp_fields
  sum: shift_states_sum_fields
  var_pop: shift_states_var_pop_fields
  var_samp: shift_states_var_samp_fields
  variance: shift_states_variance_fields
}

"aggregate avg on columns"
type shift_states_avg_fields {
  capacity: Float
  id: Float
  shift_id: Float
  state_id: Float
}

"aggregate max on columns"
type shift_states_max_fields {
  capacity: numeric
  id: Int
  shift_id: Int
  state_id: Int
}

"aggregate min on columns"
type shift_states_min_fields {
  capacity: numeric
  id: Int
  shift_id: Int
  state_id: Int
}

"response of any mutation on the table \"shift_states\""
type shift_states_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [shift_states!]!
}

"aggregate stddev on columns"
type shift_states_stddev_fields {
  capacity: Float
  id: Float
  shift_id: Float
  state_id: Float
}

"aggregate stddev_pop on columns"
type shift_states_stddev_pop_fields {
  capacity: Float
  id: Float
  shift_id: Float
  state_id: Float
}

"aggregate stddev_samp on columns"
type shift_states_stddev_samp_fields {
  capacity: Float
  id: Float
  shift_id: Float
  state_id: Float
}

"aggregate sum on columns"
type shift_states_sum_fields {
  capacity: numeric
  id: Int
  shift_id: Int
  state_id: Int
}

"aggregate var_pop on columns"
type shift_states_var_pop_fields {
  capacity: Float
  id: Float
  shift_id: Float
  state_id: Float
}

"aggregate var_samp on columns"
type shift_states_var_samp_fields {
  capacity: Float
  id: Float
  shift_id: Float
  state_id: Float
}

"aggregate variance on columns"
type shift_states_variance_fields {
  capacity: Float
  id: Float
  shift_id: Float
  state_id: Float
}

"aggregate stddev on columns"
type shift_stddev_fields {
  capacity: Float
  id: Float
  state_id: Float
}

"aggregate stddev_pop on columns"
type shift_stddev_pop_fields {
  capacity: Float
  id: Float
  state_id: Float
}

"aggregate stddev_samp on columns"
type shift_stddev_samp_fields {
  capacity: Float
  id: Float
  state_id: Float
}

"aggregate sum on columns"
type shift_sum_fields {
  capacity: Int
  id: Int
  state_id: Int
}

"aggregate var_pop on columns"
type shift_var_pop_fields {
  capacity: Float
  id: Float
  state_id: Float
}

"aggregate var_samp on columns"
type shift_var_samp_fields {
  capacity: Float
  id: Float
  state_id: Float
}

"aggregate variance on columns"
type shift_variance_fields {
  capacity: Float
  id: Float
  state_id: Float
}

"""

this table hold the state values


columns and relationships of "state"
"""
type state {
  abbreviation: String!
  id: Int!
  "An array relationship"
  schools(
    "distinct select on columns"
    distinct_on: [school_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [school_order_by!],
    "filter the rows returned"
    where: school_bool_exp
  ): [school!]!
  "An aggregated array relationship"
  schools_aggregate(
    "distinct select on columns"
    distinct_on: [school_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [school_order_by!],
    "filter the rows returned"
    where: school_bool_exp
  ): school_aggregate!
  "An array relationship"
  shifts_state(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): [shift_states!]!
  "An aggregated array relationship"
  shifts_state_aggregate(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): shift_states_aggregate!
  value: String!
}

"aggregated selection of \"state\""
type state_aggregate {
  aggregate: state_aggregate_fields
  nodes: [state!]!
}

"aggregate fields of \"state\""
type state_aggregate_fields {
  avg: state_avg_fields
  count(columns: [state_select_column!], distinct: Boolean): Int
  max: state_max_fields
  min: state_min_fields
  stddev: state_stddev_fields
  stddev_pop: state_stddev_pop_fields
  stddev_samp: state_stddev_samp_fields
  sum: state_sum_fields
  var_pop: state_var_pop_fields
  var_samp: state_var_samp_fields
  variance: state_variance_fields
}

"aggregate avg on columns"
type state_avg_fields {
  id: Float
}

"aggregate max on columns"
type state_max_fields {
  abbreviation: String
  id: Int
  value: String
}

"aggregate min on columns"
type state_min_fields {
  abbreviation: String
  id: Int
  value: String
}

"response of any mutation on the table \"state\""
type state_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [state!]!
}

"aggregate stddev on columns"
type state_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type state_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type state_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type state_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type state_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type state_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type state_variance_fields {
  id: Float
}

"""

this table hold the enrollement values for student


columns and relationships of "student_enrollment"
"""
type student_enrollment {
  auto_assigned: Boolean!
  "An object relationship"
  counselor_enrollment: counselor_enrollment
  counselor_enrollment_id: Int!
  id: Int!
  "An object relationship"
  session: session
  student_id: uuid!
}

"aggregated selection of \"student_enrollment\""
type student_enrollment_aggregate {
  aggregate: student_enrollment_aggregate_fields
  nodes: [student_enrollment!]!
}

"aggregate fields of \"student_enrollment\""
type student_enrollment_aggregate_fields {
  avg: student_enrollment_avg_fields
  count(columns: [student_enrollment_select_column!], distinct: Boolean): Int
  max: student_enrollment_max_fields
  min: student_enrollment_min_fields
  stddev: student_enrollment_stddev_fields
  stddev_pop: student_enrollment_stddev_pop_fields
  stddev_samp: student_enrollment_stddev_samp_fields
  sum: student_enrollment_sum_fields
  var_pop: student_enrollment_var_pop_fields
  var_samp: student_enrollment_var_samp_fields
  variance: student_enrollment_variance_fields
}

"aggregate avg on columns"
type student_enrollment_avg_fields {
  counselor_enrollment_id: Float
  id: Float
}

"aggregate max on columns"
type student_enrollment_max_fields {
  counselor_enrollment_id: Int
  id: Int
  student_id: uuid
}

"aggregate min on columns"
type student_enrollment_min_fields {
  counselor_enrollment_id: Int
  id: Int
  student_id: uuid
}

"response of any mutation on the table \"student_enrollment\""
type student_enrollment_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [student_enrollment!]!
}

"aggregate stddev on columns"
type student_enrollment_stddev_fields {
  counselor_enrollment_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type student_enrollment_stddev_pop_fields {
  counselor_enrollment_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type student_enrollment_stddev_samp_fields {
  counselor_enrollment_id: Float
  id: Float
}

"aggregate sum on columns"
type student_enrollment_sum_fields {
  counselor_enrollment_id: Int
  id: Int
}

"aggregate var_pop on columns"
type student_enrollment_var_pop_fields {
  counselor_enrollment_id: Float
  id: Float
}

"aggregate var_samp on columns"
type student_enrollment_var_samp_fields {
  counselor_enrollment_id: Float
  id: Float
}

"aggregate variance on columns"
type student_enrollment_variance_fields {
  counselor_enrollment_id: Float
  id: Float
}

"subscription root"
type subscription_root {
  "fetch data from the table: \"account_status\""
  account_status(
    "distinct select on columns"
    distinct_on: [account_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [account_status_order_by!],
    "filter the rows returned"
    where: account_status_bool_exp
  ): [account_status!]!
  "fetch aggregated fields from the table: \"account_status\""
  account_status_aggregate(
    "distinct select on columns"
    distinct_on: [account_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [account_status_order_by!],
    "filter the rows returned"
    where: account_status_bool_exp
  ): account_status_aggregate!
  "fetch data from the table: \"account_status\" using primary key columns"
  account_status_by_pk(value: String!): account_status
  "fetch data from the table: \"account_status_changes\""
  account_status_changes(
    "distinct select on columns"
    distinct_on: [account_status_changes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [account_status_changes_order_by!],
    "filter the rows returned"
    where: account_status_changes_bool_exp
  ): [account_status_changes!]!
  "fetch aggregated fields from the table: \"account_status_changes\""
  account_status_changes_aggregate(
    "distinct select on columns"
    distinct_on: [account_status_changes_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [account_status_changes_order_by!],
    "filter the rows returned"
    where: account_status_changes_bool_exp
  ): account_status_changes_aggregate!
  "fetch data from the table: \"account_status_changes\" using primary key columns"
  account_status_changes_by_pk(id: Int!): account_status_changes
  "fetch data from the table: \"config\""
  config(
    "distinct select on columns"
    distinct_on: [config_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [config_order_by!],
    "filter the rows returned"
    where: config_bool_exp
  ): [config!]!
  "fetch aggregated fields from the table: \"config\""
  config_aggregate(
    "distinct select on columns"
    distinct_on: [config_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [config_order_by!],
    "filter the rows returned"
    where: config_bool_exp
  ): config_aggregate!
  "fetch data from the table: \"config\" using primary key columns"
  config_by_pk(id: Int!): config
  "fetch data from the table: \"counselor_enrollment\""
  counselor_enrollment(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): [counselor_enrollment!]!
  "fetch aggregated fields from the table: \"counselor_enrollment\""
  counselor_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): counselor_enrollment_aggregate!
  "fetch data from the table: \"counselor_enrollment\" using primary key columns"
  counselor_enrollment_by_pk(id: Int!): counselor_enrollment
  "fetch data from the table: \"counselor_note_config\""
  counselor_note_config(
    "distinct select on columns"
    distinct_on: [counselor_note_config_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_note_config_order_by!],
    "filter the rows returned"
    where: counselor_note_config_bool_exp
  ): [counselor_note_config!]!
  "fetch aggregated fields from the table: \"counselor_note_config\""
  counselor_note_config_aggregate(
    "distinct select on columns"
    distinct_on: [counselor_note_config_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_note_config_order_by!],
    "filter the rows returned"
    where: counselor_note_config_bool_exp
  ): counselor_note_config_aggregate!
  "fetch data from the table: \"counselor_note_config\" using primary key columns"
  counselor_note_config_by_pk(id: Int!): counselor_note_config
  "fetch data from the table: \"counslr_request\""
  counslr_request(
    "distinct select on columns"
    distinct_on: [counslr_request_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counslr_request_order_by!],
    "filter the rows returned"
    where: counslr_request_bool_exp
  ): [counslr_request!]!
  "fetch aggregated fields from the table: \"counslr_request\""
  counslr_request_aggregate(
    "distinct select on columns"
    distinct_on: [counslr_request_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counslr_request_order_by!],
    "filter the rows returned"
    where: counslr_request_bool_exp
  ): counslr_request_aggregate!
  "fetch data from the table: \"counslr_request\" using primary key columns"
  counslr_request_by_pk(id: Int!): counslr_request
  "fetch data from the table: \"custom_note_option\""
  custom_note_option(
    "distinct select on columns"
    distinct_on: [custom_note_option_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [custom_note_option_order_by!],
    "filter the rows returned"
    where: custom_note_option_bool_exp
  ): [custom_note_option!]!
  "fetch aggregated fields from the table: \"custom_note_option\""
  custom_note_option_aggregate(
    "distinct select on columns"
    distinct_on: [custom_note_option_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [custom_note_option_order_by!],
    "filter the rows returned"
    where: custom_note_option_bool_exp
  ): custom_note_option_aggregate!
  "fetch data from the table: \"custom_note_option\" using primary key columns"
  custom_note_option_by_pk(id: Int!): custom_note_option
  "fetch data from the table: \"device\""
  device(
    "distinct select on columns"
    distinct_on: [device_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [device_order_by!],
    "filter the rows returned"
    where: device_bool_exp
  ): [device!]!
  "fetch aggregated fields from the table: \"device\""
  device_aggregate(
    "distinct select on columns"
    distinct_on: [device_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [device_order_by!],
    "filter the rows returned"
    where: device_bool_exp
  ): device_aggregate!
  "fetch data from the table: \"device\" using primary key columns"
  device_by_pk(id: Int!): device
  "fetch data from the table: \"emergency_service\""
  emergency_service(
    "distinct select on columns"
    distinct_on: [emergency_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [emergency_service_order_by!],
    "filter the rows returned"
    where: emergency_service_bool_exp
  ): [emergency_service!]!
  "fetch aggregated fields from the table: \"emergency_service\""
  emergency_service_aggregate(
    "distinct select on columns"
    distinct_on: [emergency_service_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [emergency_service_order_by!],
    "filter the rows returned"
    where: emergency_service_bool_exp
  ): emergency_service_aggregate!
  "fetch data from the table: \"emergency_service\" using primary key columns"
  emergency_service_by_pk(id: Int!): emergency_service
  "fetch data from the table: \"ethnicity\""
  ethnicity(
    "distinct select on columns"
    distinct_on: [ethnicity_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ethnicity_order_by!],
    "filter the rows returned"
    where: ethnicity_bool_exp
  ): [ethnicity!]!
  "fetch aggregated fields from the table: \"ethnicity\""
  ethnicity_aggregate(
    "distinct select on columns"
    distinct_on: [ethnicity_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ethnicity_order_by!],
    "filter the rows returned"
    where: ethnicity_bool_exp
  ): ethnicity_aggregate!
  "fetch data from the table: \"ethnicity\" using primary key columns"
  ethnicity_by_pk(id: Int!): ethnicity
  "fetch data from the table: \"gender\""
  gender(
    "distinct select on columns"
    distinct_on: [gender_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gender_order_by!],
    "filter the rows returned"
    where: gender_bool_exp
  ): [gender!]!
  "fetch aggregated fields from the table: \"gender\""
  gender_aggregate(
    "distinct select on columns"
    distinct_on: [gender_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [gender_order_by!],
    "filter the rows returned"
    where: gender_bool_exp
  ): gender_aggregate!
  "fetch data from the table: \"gender\" using primary key columns"
  gender_by_pk(id: Int!): gender
  "fetch data from the table: \"identity\""
  identity(
    "distinct select on columns"
    distinct_on: [identity_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [identity_order_by!],
    "filter the rows returned"
    where: identity_bool_exp
  ): [identity!]!
  "fetch aggregated fields from the table: \"identity\""
  identity_aggregate(
    "distinct select on columns"
    distinct_on: [identity_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [identity_order_by!],
    "filter the rows returned"
    where: identity_bool_exp
  ): identity_aggregate!
  "fetch data from the table: \"identity\" using primary key columns"
  identity_by_pk(id: String!): identity
  "fetch data from the table: \"payment_plan\""
  payment_plan(
    "distinct select on columns"
    distinct_on: [payment_plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payment_plan_order_by!],
    "filter the rows returned"
    where: payment_plan_bool_exp
  ): [payment_plan!]!
  "fetch aggregated fields from the table: \"payment_plan\""
  payment_plan_aggregate(
    "distinct select on columns"
    distinct_on: [payment_plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payment_plan_order_by!],
    "filter the rows returned"
    where: payment_plan_bool_exp
  ): payment_plan_aggregate!
  "fetch data from the table: \"payment_plan\" using primary key columns"
  payment_plan_by_pk(id: Int!): payment_plan
  "fetch data from the table: \"payout\""
  payout(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): [payout!]!
  "fetch aggregated fields from the table: \"payout\""
  payout_aggregate(
    "distinct select on columns"
    distinct_on: [payout_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_order_by!],
    "filter the rows returned"
    where: payout_bool_exp
  ): payout_aggregate!
  "fetch data from the table: \"payout\" using primary key columns"
  payout_by_pk(id: Int!): payout
  "fetch data from the table: \"payout_status\""
  payout_status(
    "distinct select on columns"
    distinct_on: [payout_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_status_order_by!],
    "filter the rows returned"
    where: payout_status_bool_exp
  ): [payout_status!]!
  "fetch aggregated fields from the table: \"payout_status\""
  payout_status_aggregate(
    "distinct select on columns"
    distinct_on: [payout_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [payout_status_order_by!],
    "filter the rows returned"
    where: payout_status_bool_exp
  ): payout_status_aggregate!
  "fetch data from the table: \"payout_status\" using primary key columns"
  payout_status_by_pk(id: Int!): payout_status
  "fetch data from the table: \"plan\""
  plan(
    "distinct select on columns"
    distinct_on: [plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [plan_order_by!],
    "filter the rows returned"
    where: plan_bool_exp
  ): [plan!]!
  "fetch aggregated fields from the table: \"plan\""
  plan_aggregate(
    "distinct select on columns"
    distinct_on: [plan_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [plan_order_by!],
    "filter the rows returned"
    where: plan_bool_exp
  ): plan_aggregate!
  "fetch data from the table: \"plan\" using primary key columns"
  plan_by_pk(id: Int!): plan
  "fetch data from the table: \"school\""
  school(
    "distinct select on columns"
    distinct_on: [school_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [school_order_by!],
    "filter the rows returned"
    where: school_bool_exp
  ): [school!]!
  "fetch aggregated fields from the table: \"school\""
  school_aggregate(
    "distinct select on columns"
    distinct_on: [school_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [school_order_by!],
    "filter the rows returned"
    where: school_bool_exp
  ): school_aggregate!
  "fetch data from the table: \"school\" using primary key columns"
  school_by_pk(id: Int!): school
  "fetch data from the table: \"session\""
  session(
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): [session!]!
  "fetch aggregated fields from the table: \"session\""
  session_aggregate(
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): session_aggregate!
  "fetch data from the table: \"session\" using primary key columns"
  session_by_pk(id: Int!): session
  "fetch data from the table: \"session_cancellation\""
  session_cancellation(
    "distinct select on columns"
    distinct_on: [session_cancellation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_cancellation_order_by!],
    "filter the rows returned"
    where: session_cancellation_bool_exp
  ): [session_cancellation!]!
  "fetch aggregated fields from the table: \"session_cancellation\""
  session_cancellation_aggregate(
    "distinct select on columns"
    distinct_on: [session_cancellation_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_cancellation_order_by!],
    "filter the rows returned"
    where: session_cancellation_bool_exp
  ): session_cancellation_aggregate!
  "fetch data from the table: \"session_cancellation\" using primary key columns"
  session_cancellation_by_pk(id: Int!): session_cancellation
  "fetch data from the table: \"session_feedback\""
  session_feedback(
    "distinct select on columns"
    distinct_on: [session_feedback_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_feedback_order_by!],
    "filter the rows returned"
    where: session_feedback_bool_exp
  ): [session_feedback!]!
  "fetch aggregated fields from the table: \"session_feedback\""
  session_feedback_aggregate(
    "distinct select on columns"
    distinct_on: [session_feedback_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_feedback_order_by!],
    "filter the rows returned"
    where: session_feedback_bool_exp
  ): session_feedback_aggregate!
  "fetch data from the table: \"session_feedback\" using primary key columns"
  session_feedback_by_pk(id: Int!): session_feedback
  "fetch data from the table: \"session_status\""
  session_status(
    "distinct select on columns"
    distinct_on: [session_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_status_order_by!],
    "filter the rows returned"
    where: session_status_bool_exp
  ): [session_status!]!
  "fetch aggregated fields from the table: \"session_status\""
  session_status_aggregate(
    "distinct select on columns"
    distinct_on: [session_status_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_status_order_by!],
    "filter the rows returned"
    where: session_status_bool_exp
  ): session_status_aggregate!
  "fetch data from the table: \"session_status\" using primary key columns"
  session_status_by_pk(id: Int!): session_status
  "fetch data from the table: \"session_topic\""
  session_topic(
    "distinct select on columns"
    distinct_on: [session_topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_topic_order_by!],
    "filter the rows returned"
    where: session_topic_bool_exp
  ): [session_topic!]!
  "fetch aggregated fields from the table: \"session_topic\""
  session_topic_aggregate(
    "distinct select on columns"
    distinct_on: [session_topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_topic_order_by!],
    "filter the rows returned"
    where: session_topic_bool_exp
  ): session_topic_aggregate!
  "fetch data from the table: \"session_topic\" using primary key columns"
  session_topic_by_pk(id: Int!): session_topic
  "fetch data from the table: \"session_type\""
  session_type(
    "distinct select on columns"
    distinct_on: [session_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_type_order_by!],
    "filter the rows returned"
    where: session_type_bool_exp
  ): [session_type!]!
  "fetch aggregated fields from the table: \"session_type\""
  session_type_aggregate(
    "distinct select on columns"
    distinct_on: [session_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_type_order_by!],
    "filter the rows returned"
    where: session_type_bool_exp
  ): session_type_aggregate!
  "fetch data from the table: \"session_type\" using primary key columns"
  session_type_by_pk(id: Int!): session_type
  "execute function \"sessionsOlderThan\" which returns \"session\""
  sessionsOlderThan(
    "input parameters for function \"sessionsOlderThan\""
    args: sessionsOlderThan_args!,
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): [session!]!
  "execute function \"sessionsOlderThan\" and query aggregates on result of table type \"session\""
  sessionsOlderThan_aggregate(
    "input parameters for function \"sessionsOlderThan\""
    args: sessionsOlderThan_args!,
    "distinct select on columns"
    distinct_on: [session_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_order_by!],
    "filter the rows returned"
    where: session_bool_exp
  ): session_aggregate!
  "fetch data from the table: \"sexuality\""
  sexuality(
    "distinct select on columns"
    distinct_on: [sexuality_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sexuality_order_by!],
    "filter the rows returned"
    where: sexuality_bool_exp
  ): [sexuality!]!
  "fetch aggregated fields from the table: \"sexuality\""
  sexuality_aggregate(
    "distinct select on columns"
    distinct_on: [sexuality_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [sexuality_order_by!],
    "filter the rows returned"
    where: sexuality_bool_exp
  ): sexuality_aggregate!
  "fetch data from the table: \"sexuality\" using primary key columns"
  sexuality_by_pk(id: Int!): sexuality
  "fetch data from the table: \"shift\""
  shift(
    "distinct select on columns"
    distinct_on: [shift_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_order_by!],
    "filter the rows returned"
    where: shift_bool_exp
  ): [shift!]!
  "fetch aggregated fields from the table: \"shift\""
  shift_aggregate(
    "distinct select on columns"
    distinct_on: [shift_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_order_by!],
    "filter the rows returned"
    where: shift_bool_exp
  ): shift_aggregate!
  "fetch data from the table: \"shift\" using primary key columns"
  shift_by_pk(id: Int!): shift
  "fetch data from the table: \"shift_states\""
  shift_states(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): [shift_states!]!
  "fetch aggregated fields from the table: \"shift_states\""
  shift_states_aggregate(
    "distinct select on columns"
    distinct_on: [shift_states_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [shift_states_order_by!],
    "filter the rows returned"
    where: shift_states_bool_exp
  ): shift_states_aggregate!
  "fetch data from the table: \"shift_states\" using primary key columns"
  shift_states_by_pk(id: Int!): shift_states
  "fetch data from the table: \"state\""
  state(
    "distinct select on columns"
    distinct_on: [state_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [state_order_by!],
    "filter the rows returned"
    where: state_bool_exp
  ): [state!]!
  "fetch aggregated fields from the table: \"state\""
  state_aggregate(
    "distinct select on columns"
    distinct_on: [state_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [state_order_by!],
    "filter the rows returned"
    where: state_bool_exp
  ): state_aggregate!
  "fetch data from the table: \"state\" using primary key columns"
  state_by_pk(id: Int!): state
  "fetch data from the table: \"student_enrollment\""
  student_enrollment(
    "distinct select on columns"
    distinct_on: [student_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [student_enrollment_order_by!],
    "filter the rows returned"
    where: student_enrollment_bool_exp
  ): [student_enrollment!]!
  "fetch aggregated fields from the table: \"student_enrollment\""
  student_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [student_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [student_enrollment_order_by!],
    "filter the rows returned"
    where: student_enrollment_bool_exp
  ): student_enrollment_aggregate!
  "fetch data from the table: \"student_enrollment\" using primary key columns"
  student_enrollment_by_pk(id: Int!): student_enrollment
  "fetch data from the table: \"topic\""
  topic(
    "distinct select on columns"
    distinct_on: [topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [topic_order_by!],
    "filter the rows returned"
    where: topic_bool_exp
  ): [topic!]!
  "fetch aggregated fields from the table: \"topic\""
  topic_aggregate(
    "distinct select on columns"
    distinct_on: [topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [topic_order_by!],
    "filter the rows returned"
    where: topic_bool_exp
  ): topic_aggregate!
  "fetch data from the table: \"topic\" using primary key columns"
  topic_by_pk(id: Int!): topic
  "fetch data from the table: \"user\""
  user(
    "distinct select on columns"
    distinct_on: [user_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_order_by!],
    "filter the rows returned"
    where: user_bool_exp
  ): [user!]!
  "fetch aggregated fields from the table: \"user\""
  user_aggregate(
    "distinct select on columns"
    distinct_on: [user_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_order_by!],
    "filter the rows returned"
    where: user_bool_exp
  ): user_aggregate!
  "fetch data from the table: \"user\" using primary key columns"
  user_by_pk(id: uuid!): user
  "fetch data from the table: \"user_type\""
  user_type(
    "distinct select on columns"
    distinct_on: [user_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_type_order_by!],
    "filter the rows returned"
    where: user_type_bool_exp
  ): [user_type!]!
  "fetch aggregated fields from the table: \"user_type\""
  user_type_aggregate(
    "distinct select on columns"
    distinct_on: [user_type_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [user_type_order_by!],
    "filter the rows returned"
    where: user_type_bool_exp
  ): user_type_aggregate!
  "fetch data from the table: \"user_type\" using primary key columns"
  user_type_by_pk(id: Int!): user_type
}

"""

this table hold the topic values


columns and relationships of "topic"
"""
type topic {
  description: String!
  id: Int!
  "An array relationship"
  session_topic(
    "distinct select on columns"
    distinct_on: [session_topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_topic_order_by!],
    "filter the rows returned"
    where: session_topic_bool_exp
  ): [session_topic!]!
  "An aggregated array relationship"
  session_topic_aggregate(
    "distinct select on columns"
    distinct_on: [session_topic_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [session_topic_order_by!],
    "filter the rows returned"
    where: session_topic_bool_exp
  ): session_topic_aggregate!
}

"aggregated selection of \"topic\""
type topic_aggregate {
  aggregate: topic_aggregate_fields
  nodes: [topic!]!
}

"aggregate fields of \"topic\""
type topic_aggregate_fields {
  avg: topic_avg_fields
  count(columns: [topic_select_column!], distinct: Boolean): Int
  max: topic_max_fields
  min: topic_min_fields
  stddev: topic_stddev_fields
  stddev_pop: topic_stddev_pop_fields
  stddev_samp: topic_stddev_samp_fields
  sum: topic_sum_fields
  var_pop: topic_var_pop_fields
  var_samp: topic_var_samp_fields
  variance: topic_variance_fields
}

"aggregate avg on columns"
type topic_avg_fields {
  id: Float
}

"aggregate max on columns"
type topic_max_fields {
  description: String
  id: Int
}

"aggregate min on columns"
type topic_min_fields {
  description: String
  id: Int
}

"response of any mutation on the table \"topic\""
type topic_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [topic!]!
}

"aggregate stddev on columns"
type topic_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type topic_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type topic_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type topic_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type topic_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type topic_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type topic_variance_fields {
  id: Float
}

"""

this table hold the trueVault data for user


columns and relationships of "user"
"""
type user {
  "An array relationship"
  counselor_enrollment(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): [counselor_enrollment!]!
  "An aggregated array relationship"
  counselor_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [counselor_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [counselor_enrollment_order_by!],
    "filter the rows returned"
    where: counselor_enrollment_bool_exp
  ): counselor_enrollment_aggregate!
  "An array relationship"
  devices(
    "distinct select on columns"
    distinct_on: [device_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [device_order_by!],
    "filter the rows returned"
    where: device_bool_exp
  ): [device!]!
  "An aggregated array relationship"
  devices_aggregate(
    "distinct select on columns"
    distinct_on: [device_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [device_order_by!],
    "filter the rows returned"
    where: device_bool_exp
  ): device_aggregate!
  enabled: Boolean
  group_id: uuid
  id: uuid!
  "An object relationship"
  identity: identity
  identity_id: String
  last_login_date: timestamptz!
  onboarding_completed: Boolean
  profile_document_id: uuid
  "An object relationship"
  school: school
  school_id: Int
  stripe_user_id: String
  "An array relationship"
  student_enrollment(
    "distinct select on columns"
    distinct_on: [student_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [student_enrollment_order_by!],
    "filter the rows returned"
    where: student_enrollment_bool_exp
  ): [student_enrollment!]!
  "An aggregated array relationship"
  student_enrollment_aggregate(
    "distinct select on columns"
    distinct_on: [student_enrollment_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [student_enrollment_order_by!],
    "filter the rows returned"
    where: student_enrollment_bool_exp
  ): student_enrollment_aggregate!
  "An object relationship"
  user_type: user_type
  user_type_id: Int!
}

"aggregated selection of \"user\""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"aggregate fields of \"user\""
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

"aggregate avg on columns"
type user_avg_fields {
  school_id: Float
  user_type_id: Float
}

"aggregate max on columns"
type user_max_fields {
  group_id: uuid
  id: uuid
  identity_id: String
  last_login_date: timestamptz
  profile_document_id: uuid
  school_id: Int
  stripe_user_id: String
  user_type_id: Int
}

"aggregate min on columns"
type user_min_fields {
  group_id: uuid
  id: uuid
  identity_id: String
  last_login_date: timestamptz
  profile_document_id: uuid
  school_id: Int
  stripe_user_id: String
  user_type_id: Int
}

"response of any mutation on the table \"user\""
type user_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [user!]!
}

"aggregate stddev on columns"
type user_stddev_fields {
  school_id: Float
  user_type_id: Float
}

"aggregate stddev_pop on columns"
type user_stddev_pop_fields {
  school_id: Float
  user_type_id: Float
}

"aggregate stddev_samp on columns"
type user_stddev_samp_fields {
  school_id: Float
  user_type_id: Float
}

"aggregate sum on columns"
type user_sum_fields {
  school_id: Int
  user_type_id: Int
}

"""

this table hold the user type value


columns and relationships of "user_type"
"""
type user_type {
  id: Int!
  value: String!
}

"aggregated selection of \"user_type\""
type user_type_aggregate {
  aggregate: user_type_aggregate_fields
  nodes: [user_type!]!
}

"aggregate fields of \"user_type\""
type user_type_aggregate_fields {
  avg: user_type_avg_fields
  count(columns: [user_type_select_column!], distinct: Boolean): Int
  max: user_type_max_fields
  min: user_type_min_fields
  stddev: user_type_stddev_fields
  stddev_pop: user_type_stddev_pop_fields
  stddev_samp: user_type_stddev_samp_fields
  sum: user_type_sum_fields
  var_pop: user_type_var_pop_fields
  var_samp: user_type_var_samp_fields
  variance: user_type_variance_fields
}

"aggregate avg on columns"
type user_type_avg_fields {
  id: Float
}

"aggregate max on columns"
type user_type_max_fields {
  id: Int
  value: String
}

"aggregate min on columns"
type user_type_min_fields {
  id: Int
  value: String
}

"response of any mutation on the table \"user_type\""
type user_type_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [user_type!]!
}

"aggregate stddev on columns"
type user_type_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type user_type_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type user_type_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type user_type_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type user_type_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type user_type_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type user_type_variance_fields {
  id: Float
}

"aggregate var_pop on columns"
type user_var_pop_fields {
  school_id: Float
  user_type_id: Float
}

"aggregate var_samp on columns"
type user_var_samp_fields {
  school_id: Float
  user_type_id: Float
}

"aggregate variance on columns"
type user_variance_fields {
  school_id: Float
  user_type_id: Float
}

"unique or primary key constraints on table \"account_status_changes\""
enum account_status_changes_constraint {
  "unique or primary key constraint"
  account_status_changes_pkey
}

"select columns of table \"account_status_changes\""
enum account_status_changes_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  status
  "column name"
  user_id
}

"update columns of table \"account_status_changes\""
enum account_status_changes_update_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  status
  "column name"
  user_id
}

"unique or primary key constraints on table \"account_status\""
enum account_status_constraint {
  "unique or primary key constraint"
  account_status_pkey
}

enum account_status_enum {
  "Account Status active"
  active
  "Account was deactivated"
  deactivated
}

"select columns of table \"account_status\""
enum account_status_select_column {
  "column name"
  comment
  "column name"
  value
}

"update columns of table \"account_status\""
enum account_status_update_column {
  "column name"
  comment
  "column name"
  value
}

"unique or primary key constraints on table \"config\""
enum config_constraint {
  "unique or primary key constraint"
  config_config_id_key
  "unique or primary key constraint"
  config_pkey
}

"select columns of table \"config\""
enum config_select_column {
  "column name"
  chat_now_frequency_hours
  "column name"
  chats_vault_id
  "column name"
  counselor_shift_capacity
  "column name"
  counslr_resources_url
  "column name"
  counslr_website
  "column name"
  failed_attempts_count
  "column name"
  id
  "column name"
  max_backups_per_shift
  "column name"
  max_schedule_weeks_threshold
  "column name"
  max_shift_duration_hours
  "column name"
  max_students_per_counselor_shift
  "column name"
  min_shift_duration_hours
  "column name"
  notes_submit_hours_threshold
  "column name"
  notes_vault_id
  "column name"
  privacy_policy_url
  "column name"
  stripe_client_id
  "column name"
  support_email
  "column name"
  terms_url
}

"update columns of table \"config\""
enum config_update_column {
  "column name"
  chat_now_frequency_hours
  "column name"
  chats_vault_id
  "column name"
  counselor_shift_capacity
  "column name"
  counslr_resources_url
  "column name"
  counslr_website
  "column name"
  failed_attempts_count
  "column name"
  id
  "column name"
  max_backups_per_shift
  "column name"
  max_schedule_weeks_threshold
  "column name"
  max_shift_duration_hours
  "column name"
  max_students_per_counselor_shift
  "column name"
  min_shift_duration_hours
  "column name"
  notes_submit_hours_threshold
  "column name"
  notes_vault_id
  "column name"
  privacy_policy_url
  "column name"
  stripe_client_id
  "column name"
  support_email
  "column name"
  terms_url
}

"unique or primary key constraints on table \"counselor_enrollment\""
enum counselor_enrollment_constraint {
  "unique or primary key constraint"
  counselor_enrollment_pkey
}

"select columns of table \"counselor_enrollment\""
enum counselor_enrollment_select_column {
  "column name"
  backup
  "column name"
  backup_position
  "column name"
  counselor_id
  "column name"
  id
  "column name"
  shift_id
  "column name"
  shift_states_id
}

"update columns of table \"counselor_enrollment\""
enum counselor_enrollment_update_column {
  "column name"
  backup
  "column name"
  backup_position
  "column name"
  counselor_id
  "column name"
  id
  "column name"
  shift_id
  "column name"
  shift_states_id
}

"unique or primary key constraints on table \"counselor_note_config\""
enum counselor_note_config_constraint {
  "unique or primary key constraint"
  counselor_note_config_pkey
}

"select columns of table \"counselor_note_config\""
enum counselor_note_config_select_column {
  "column name"
  active
  "column name"
  id
  "column name"
  key
  "column name"
  max_length
  "column name"
  order
  "column name"
  title
  "column name"
  type
}

"update columns of table \"counselor_note_config\""
enum counselor_note_config_update_column {
  "column name"
  active
  "column name"
  id
  "column name"
  key
  "column name"
  max_length
  "column name"
  order
  "column name"
  title
  "column name"
  type
}

"unique or primary key constraints on table \"counslr_request\""
enum counslr_request_constraint {
  "unique or primary key constraint"
  counslr_request_pkey
}

"select columns of table \"counslr_request\""
enum counslr_request_select_column {
  "column name"
  email
  "column name"
  id
}

"update columns of table \"counslr_request\""
enum counslr_request_update_column {
  "column name"
  email
  "column name"
  id
}

"unique or primary key constraints on table \"custom_note_option\""
enum custom_note_option_constraint {
  "unique or primary key constraint"
  custom_note_option_pkey
}

"select columns of table \"custom_note_option\""
enum custom_note_option_select_column {
  "column name"
  active
  "column name"
  counselor_note_config_id
  "column name"
  id
  "column name"
  value
}

"update columns of table \"custom_note_option\""
enum custom_note_option_update_column {
  "column name"
  active
  "column name"
  counselor_note_config_id
  "column name"
  id
  "column name"
  value
}

"unique or primary key constraints on table \"device\""
enum device_constraint {
  "unique or primary key constraint"
  device_pkey
}

"select columns of table \"device\""
enum device_select_column {
  "column name"
  created_date
  "column name"
  id
  "column name"
  name
  "column name"
  platform
  "column name"
  token
  "column name"
  user_id
}

"update columns of table \"device\""
enum device_update_column {
  "column name"
  created_date
  "column name"
  id
  "column name"
  name
  "column name"
  platform
  "column name"
  token
  "column name"
  user_id
}

"unique or primary key constraints on table \"emergency_service\""
enum emergency_service_constraint {
  "unique or primary key constraint"
  emergency_service_pkey
}

"select columns of table \"emergency_service\""
enum emergency_service_select_column {
  "column name"
  id
  "column name"
  name
  "column name"
  phone
  "column name"
  school_id
}

"update columns of table \"emergency_service\""
enum emergency_service_update_column {
  "column name"
  id
  "column name"
  name
  "column name"
  phone
  "column name"
  school_id
}

"unique or primary key constraints on table \"ethnicity\""
enum ethnicity_constraint {
  "unique or primary key constraint"
  ethnicity_pkey
}

"select columns of table \"ethnicity\""
enum ethnicity_select_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"ethnicity\""
enum ethnicity_update_column {
  "column name"
  id
  "column name"
  value
}

"unique or primary key constraints on table \"gender\""
enum gender_constraint {
  "unique or primary key constraint"
  gender_pkey
}

"select columns of table \"gender\""
enum gender_select_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"gender\""
enum gender_update_column {
  "column name"
  id
  "column name"
  value
}

"unique or primary key constraints on table \"identity\""
enum identity_constraint {
  "unique or primary key constraint"
  identity_pkey
}

"select columns of table \"identity\""
enum identity_select_column {
  "column name"
  id
  "column name"
  school_id
}

"update columns of table \"identity\""
enum identity_update_column {
  "column name"
  id
  "column name"
  school_id
}

"column ordering options"
enum order_by {
  "in the ascending order, nulls last"
  asc
  "in the ascending order, nulls first"
  asc_nulls_first
  "in the ascending order, nulls last"
  asc_nulls_last
  "in the descending order, nulls first"
  desc
  "in the descending order, nulls first"
  desc_nulls_first
  "in the descending order, nulls last"
  desc_nulls_last
}

"unique or primary key constraints on table \"payment_plan\""
enum payment_plan_constraint {
  "unique or primary key constraint"
  payment_plan_pkey
}

"select columns of table \"payment_plan\""
enum payment_plan_select_column {
  "column name"
  id
  "column name"
  session_hourly_rate
  "column name"
  shift_hourly_rate
  "column name"
  start_date
}

"update columns of table \"payment_plan\""
enum payment_plan_update_column {
  "column name"
  id
  "column name"
  session_hourly_rate
  "column name"
  shift_hourly_rate
  "column name"
  start_date
}

"unique or primary key constraints on table \"payout\""
enum payout_constraint {
  "unique or primary key constraint"
  payout_pkey
}

"select columns of table \"payout\""
enum payout_select_column {
  "column name"
  amount
  "column name"
  counselor_enrollment_id
  "column name"
  date
  "column name"
  id
  "column name"
  payment_plan_id
  "column name"
  payout_status_id
  "column name"
  session_id
  "column name"
  transaction_id
}

"unique or primary key constraints on table \"payout_status\""
enum payout_status_constraint {
  "unique or primary key constraint"
  payout_status_pkey
}

"select columns of table \"payout_status\""
enum payout_status_select_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"payout_status\""
enum payout_status_update_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"payout\""
enum payout_update_column {
  "column name"
  amount
  "column name"
  counselor_enrollment_id
  "column name"
  date
  "column name"
  id
  "column name"
  payment_plan_id
  "column name"
  payout_status_id
  "column name"
  session_id
  "column name"
  transaction_id
}

"unique or primary key constraints on table \"plan\""
enum plan_constraint {
  "unique or primary key constraint"
  plan_pkey
}

"select columns of table \"plan\""
enum plan_select_column {
  "column name"
  frequency
  "column name"
  id
  "column name"
  name
  "column name"
  sessions_count
}

"update columns of table \"plan\""
enum plan_update_column {
  "column name"
  frequency
  "column name"
  id
  "column name"
  name
  "column name"
  sessions_count
}

"unique or primary key constraints on table \"school\""
enum school_constraint {
  "unique or primary key constraint"
  school_pkey
}

"select columns of table \"school\""
enum school_select_column {
  "column name"
  address
  "column name"
  enabled
  "column name"
  id
  "column name"
  issuer
  "column name"
  logo
  "column name"
  name
  "column name"
  phone
  "column name"
  plan_id
  "column name"
  resources
  "column name"
  state_id
}

"update columns of table \"school\""
enum school_update_column {
  "column name"
  address
  "column name"
  enabled
  "column name"
  id
  "column name"
  issuer
  "column name"
  logo
  "column name"
  name
  "column name"
  phone
  "column name"
  plan_id
  "column name"
  resources
  "column name"
  state_id
}

"unique or primary key constraints on table \"session_cancellation\""
enum session_cancellation_constraint {
  "unique or primary key constraint"
  session_cancellation_pkey
}

"select columns of table \"session_cancellation\""
enum session_cancellation_select_column {
  "column name"
  cancellation_date_time
  "column name"
  cancellation_extra_details
  "column name"
  cancellation_reason
  "column name"
  id
  "column name"
  session_id
}

"update columns of table \"session_cancellation\""
enum session_cancellation_update_column {
  "column name"
  cancellation_date_time
  "column name"
  cancellation_extra_details
  "column name"
  cancellation_reason
  "column name"
  id
  "column name"
  session_id
}

"unique or primary key constraints on table \"session\""
enum session_constraint {
  "unique or primary key constraint"
  session_pkey
}

"unique or primary key constraints on table \"session_feedback\""
enum session_feedback_constraint {
  "unique or primary key constraint"
  session_feedback_pkey
}

"select columns of table \"session_feedback\""
enum session_feedback_select_column {
  "column name"
  comment
  "column name"
  helpful
  "column name"
  id
  "column name"
  session_id
}

"update columns of table \"session_feedback\""
enum session_feedback_update_column {
  "column name"
  comment
  "column name"
  helpful
  "column name"
  id
  "column name"
  session_id
}

"select columns of table \"session\""
enum session_select_column {
  "column name"
  chat_channel_id
  "column name"
  chat_document_id
  "column name"
  cleanup_session
  "column name"
  counselor_enrollment_id
  "column name"
  counselor_id
  "column name"
  description
  "column name"
  end_date
  "column name"
  id
  "column name"
  note_document_id
  "column name"
  scheduled_end_date
  "column name"
  scheduled_start_date
  "column name"
  session_reminder_1m
  "column name"
  session_reminder_30m
  "column name"
  session_status_id
  "column name"
  session_type_id
  "column name"
  start_date
  "column name"
  student_enrollment_id
  "column name"
  student_id
}

"unique or primary key constraints on table \"session_status\""
enum session_status_constraint {
  "unique or primary key constraint"
  session_status_pkey
}

"select columns of table \"session_status\""
enum session_status_select_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"session_status\""
enum session_status_update_column {
  "column name"
  id
  "column name"
  value
}

"unique or primary key constraints on table \"session_topic\""
enum session_topic_constraint {
  "unique or primary key constraint"
  session_topic_pkey
}

"select columns of table \"session_topic\""
enum session_topic_select_column {
  "column name"
  id
  "column name"
  session_id
  "column name"
  topic_id
}

"update columns of table \"session_topic\""
enum session_topic_update_column {
  "column name"
  id
  "column name"
  session_id
  "column name"
  topic_id
}

"unique or primary key constraints on table \"session_type\""
enum session_type_constraint {
  "unique or primary key constraint"
  session_type_pkey
}

"select columns of table \"session_type\""
enum session_type_select_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"session_type\""
enum session_type_update_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"session\""
enum session_update_column {
  "column name"
  chat_channel_id
  "column name"
  chat_document_id
  "column name"
  cleanup_session
  "column name"
  counselor_enrollment_id
  "column name"
  counselor_id
  "column name"
  description
  "column name"
  end_date
  "column name"
  id
  "column name"
  note_document_id
  "column name"
  scheduled_end_date
  "column name"
  scheduled_start_date
  "column name"
  session_reminder_1m
  "column name"
  session_reminder_30m
  "column name"
  session_status_id
  "column name"
  session_type_id
  "column name"
  start_date
  "column name"
  student_enrollment_id
  "column name"
  student_id
}

"unique or primary key constraints on table \"sexuality\""
enum sexuality_constraint {
  "unique or primary key constraint"
  sexuality_pkey
}

"select columns of table \"sexuality\""
enum sexuality_select_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"sexuality\""
enum sexuality_update_column {
  "column name"
  id
  "column name"
  value
}

"unique or primary key constraints on table \"shift\""
enum shift_constraint {
  "unique or primary key constraint"
  shift_pkey
}

"select columns of table \"shift\""
enum shift_select_column {
  "column name"
  admin_id
  "column name"
  capacity
  "column name"
  created_date
  "column name"
  end_date
  "column name"
  id
  "column name"
  start_date
  "column name"
  state_id
}

"unique or primary key constraints on table \"shift_states\""
enum shift_states_constraint {
  "unique or primary key constraint"
  shift_states_pkey
}

"select columns of table \"shift_states\""
enum shift_states_select_column {
  "column name"
  capacity
  "column name"
  id
  "column name"
  shift_id
  "column name"
  state_id
}

"update columns of table \"shift_states\""
enum shift_states_update_column {
  "column name"
  capacity
  "column name"
  id
  "column name"
  shift_id
  "column name"
  state_id
}

"update columns of table \"shift\""
enum shift_update_column {
  "column name"
  admin_id
  "column name"
  capacity
  "column name"
  created_date
  "column name"
  end_date
  "column name"
  id
  "column name"
  start_date
  "column name"
  state_id
}

"unique or primary key constraints on table \"state\""
enum state_constraint {
  "unique or primary key constraint"
  state_pkey
}

"select columns of table \"state\""
enum state_select_column {
  "column name"
  abbreviation
  "column name"
  id
  "column name"
  value
}

"update columns of table \"state\""
enum state_update_column {
  "column name"
  abbreviation
  "column name"
  id
  "column name"
  value
}

"unique or primary key constraints on table \"student_enrollment\""
enum student_enrollment_constraint {
  "unique or primary key constraint"
  student_enrollment_pkey
}

"select columns of table \"student_enrollment\""
enum student_enrollment_select_column {
  "column name"
  auto_assigned
  "column name"
  counselor_enrollment_id
  "column name"
  id
  "column name"
  student_id
}

"update columns of table \"student_enrollment\""
enum student_enrollment_update_column {
  "column name"
  auto_assigned
  "column name"
  counselor_enrollment_id
  "column name"
  id
  "column name"
  student_id
}

"unique or primary key constraints on table \"topic\""
enum topic_constraint {
  "unique or primary key constraint"
  topic_pkey
}

"select columns of table \"topic\""
enum topic_select_column {
  "column name"
  description
  "column name"
  id
}

"update columns of table \"topic\""
enum topic_update_column {
  "column name"
  description
  "column name"
  id
}

"unique or primary key constraints on table \"user\""
enum user_constraint {
  "unique or primary key constraint"
  user_pkey
}

"select columns of table \"user\""
enum user_select_column {
  "column name"
  enabled
  "column name"
  group_id
  "column name"
  id
  "column name"
  identity_id
  "column name"
  last_login_date
  "column name"
  onboarding_completed
  "column name"
  profile_document_id
  "column name"
  school_id
  "column name"
  stripe_user_id
  "column name"
  user_type_id
}

"unique or primary key constraints on table \"user_type\""
enum user_type_constraint {
  "unique or primary key constraint"
  user_type_pkey
}

"select columns of table \"user_type\""
enum user_type_select_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"user_type\""
enum user_type_update_column {
  "column name"
  id
  "column name"
  value
}

"update columns of table \"user\""
enum user_update_column {
  "column name"
  enabled
  "column name"
  group_id
  "column name"
  id
  "column name"
  identity_id
  "column name"
  last_login_date
  "column name"
  onboarding_completed
  "column name"
  profile_document_id
  "column name"
  school_id
  "column name"
  stripe_user_id
  "column name"
  user_type_id
}

"expression to compare columns of type Boolean. All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input EmergencyServiceInput {
  delete: Boolean
  id: Int
  name: String!
  phone: String!
}

"expression to compare columns of type Int. All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input SchoolInput {
  address: String
  emergency_services: [EmergencyServiceInput!]
  enabled: Boolean
  file: String
  id: Int
  issuer: String
  logo: String
  name: String
  phone: String
  plan_id: Int
  resources: String
}

"expression to compare columns of type String. All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"order by aggregate values of table \"account_status\""
input account_status_aggregate_order_by {
  count: order_by
  max: account_status_max_order_by
  min: account_status_min_order_by
}

"input type for inserting array relation for remote table \"account_status\""
input account_status_arr_rel_insert_input {
  data: [account_status_insert_input!]!
  on_conflict: account_status_on_conflict
}

"Boolean expression to filter rows from the table \"account_status\". All fields are combined with a logical 'AND'."
input account_status_bool_exp {
  _and: [account_status_bool_exp]
  _not: account_status_bool_exp
  _or: [account_status_bool_exp]
  comment: String_comparison_exp
  value: String_comparison_exp
}

"order by aggregate values of table \"account_status_changes\""
input account_status_changes_aggregate_order_by {
  avg: account_status_changes_avg_order_by
  count: order_by
  max: account_status_changes_max_order_by
  min: account_status_changes_min_order_by
  stddev: account_status_changes_stddev_order_by
  stddev_pop: account_status_changes_stddev_pop_order_by
  stddev_samp: account_status_changes_stddev_samp_order_by
  sum: account_status_changes_sum_order_by
  var_pop: account_status_changes_var_pop_order_by
  var_samp: account_status_changes_var_samp_order_by
  variance: account_status_changes_variance_order_by
}

"input type for inserting array relation for remote table \"account_status_changes\""
input account_status_changes_arr_rel_insert_input {
  data: [account_status_changes_insert_input!]!
  on_conflict: account_status_changes_on_conflict
}

"order by avg() on columns of table \"account_status_changes\""
input account_status_changes_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"account_status_changes\". All fields are combined with a logical 'AND'."
input account_status_changes_bool_exp {
  _and: [account_status_changes_bool_exp]
  _not: account_status_changes_bool_exp
  _or: [account_status_changes_bool_exp]
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  status: account_status_enum_comparison_exp
  user_id: uuid_comparison_exp
}

"input type for incrementing integer column in table \"account_status_changes\""
input account_status_changes_inc_input {
  id: Int
}

"input type for inserting data into table \"account_status_changes\""
input account_status_changes_insert_input {
  created_at: timestamptz
  id: Int
  status: account_status_enum
  user_id: uuid
}

"order by max() on columns of table \"account_status_changes\""
input account_status_changes_max_order_by {
  created_at: order_by
  id: order_by
  user_id: order_by
}

"order by min() on columns of table \"account_status_changes\""
input account_status_changes_min_order_by {
  created_at: order_by
  id: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"account_status_changes\""
input account_status_changes_obj_rel_insert_input {
  data: account_status_changes_insert_input!
  on_conflict: account_status_changes_on_conflict
}

"on conflict condition type for table \"account_status_changes\""
input account_status_changes_on_conflict {
  constraint: account_status_changes_constraint!
  update_columns: [account_status_changes_update_column!]!
  where: account_status_changes_bool_exp
}

"ordering options when selecting data from \"account_status_changes\""
input account_status_changes_order_by {
  created_at: order_by
  id: order_by
  status: order_by
  user_id: order_by
}

"primary key columns input for table: \"account_status_changes\""
input account_status_changes_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"account_status_changes\""
input account_status_changes_set_input {
  created_at: timestamptz
  id: Int
  status: account_status_enum
  user_id: uuid
}

"order by stddev() on columns of table \"account_status_changes\""
input account_status_changes_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"account_status_changes\""
input account_status_changes_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"account_status_changes\""
input account_status_changes_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"account_status_changes\""
input account_status_changes_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"account_status_changes\""
input account_status_changes_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"account_status_changes\""
input account_status_changes_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"account_status_changes\""
input account_status_changes_variance_order_by {
  id: order_by
}

"expression to compare columns of type account_status_enum. All fields are combined with logical 'AND'."
input account_status_enum_comparison_exp {
  _eq: account_status_enum
  _in: [account_status_enum!]
  _is_null: Boolean
  _neq: account_status_enum
  _nin: [account_status_enum!]
}

"input type for inserting data into table \"account_status\""
input account_status_insert_input {
  comment: String
  value: String
}

"order by max() on columns of table \"account_status\""
input account_status_max_order_by {
  comment: order_by
  value: order_by
}

"order by min() on columns of table \"account_status\""
input account_status_min_order_by {
  comment: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"account_status\""
input account_status_obj_rel_insert_input {
  data: account_status_insert_input!
  on_conflict: account_status_on_conflict
}

"on conflict condition type for table \"account_status\""
input account_status_on_conflict {
  constraint: account_status_constraint!
  update_columns: [account_status_update_column!]!
  where: account_status_bool_exp
}

"ordering options when selecting data from \"account_status\""
input account_status_order_by {
  comment: order_by
  value: order_by
}

"primary key columns input for table: \"account_status\""
input account_status_pk_columns_input {
  value: String!
}

"input type for updating data in table \"account_status\""
input account_status_set_input {
  comment: String
  value: String
}

"order by aggregate values of table \"config\""
input config_aggregate_order_by {
  avg: config_avg_order_by
  count: order_by
  max: config_max_order_by
  min: config_min_order_by
  stddev: config_stddev_order_by
  stddev_pop: config_stddev_pop_order_by
  stddev_samp: config_stddev_samp_order_by
  sum: config_sum_order_by
  var_pop: config_var_pop_order_by
  var_samp: config_var_samp_order_by
  variance: config_variance_order_by
}

"input type for inserting array relation for remote table \"config\""
input config_arr_rel_insert_input {
  data: [config_insert_input!]!
  on_conflict: config_on_conflict
}

"order by avg() on columns of table \"config\""
input config_avg_order_by {
  chat_now_frequency_hours: order_by
  counselor_shift_capacity: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
}

"Boolean expression to filter rows from the table \"config\". All fields are combined with a logical 'AND'."
input config_bool_exp {
  _and: [config_bool_exp]
  _not: config_bool_exp
  _or: [config_bool_exp]
  chat_now_frequency_hours: Int_comparison_exp
  chats_vault_id: uuid_comparison_exp
  counselor_shift_capacity: Int_comparison_exp
  counslr_resources_url: String_comparison_exp
  counslr_website: String_comparison_exp
  failed_attempts_count: Int_comparison_exp
  id: Int_comparison_exp
  max_backups_per_shift: Int_comparison_exp
  max_schedule_weeks_threshold: Int_comparison_exp
  max_shift_duration_hours: Int_comparison_exp
  max_students_per_counselor_shift: Int_comparison_exp
  min_shift_duration_hours: Int_comparison_exp
  notes_submit_hours_threshold: Int_comparison_exp
  notes_vault_id: uuid_comparison_exp
  privacy_policy_url: String_comparison_exp
  stripe_client_id: String_comparison_exp
  support_email: String_comparison_exp
  terms_url: String_comparison_exp
}

"input type for incrementing integer column in table \"config\""
input config_inc_input {
  chat_now_frequency_hours: Int
  counselor_shift_capacity: Int
  failed_attempts_count: Int
  id: Int
  max_backups_per_shift: Int
  max_schedule_weeks_threshold: Int
  max_shift_duration_hours: Int
  max_students_per_counselor_shift: Int
  min_shift_duration_hours: Int
  notes_submit_hours_threshold: Int
}

"input type for inserting data into table \"config\""
input config_insert_input {
  chat_now_frequency_hours: Int
  chats_vault_id: uuid
  counselor_shift_capacity: Int
  counslr_resources_url: String
  counslr_website: String
  failed_attempts_count: Int
  id: Int
  max_backups_per_shift: Int
  max_schedule_weeks_threshold: Int
  max_shift_duration_hours: Int
  max_students_per_counselor_shift: Int
  min_shift_duration_hours: Int
  notes_submit_hours_threshold: Int
  notes_vault_id: uuid
  privacy_policy_url: String
  stripe_client_id: String
  support_email: String
  terms_url: String
}

"order by max() on columns of table \"config\""
input config_max_order_by {
  chat_now_frequency_hours: order_by
  chats_vault_id: order_by
  counselor_shift_capacity: order_by
  counslr_resources_url: order_by
  counslr_website: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
  notes_vault_id: order_by
  privacy_policy_url: order_by
  stripe_client_id: order_by
  support_email: order_by
  terms_url: order_by
}

"order by min() on columns of table \"config\""
input config_min_order_by {
  chat_now_frequency_hours: order_by
  chats_vault_id: order_by
  counselor_shift_capacity: order_by
  counslr_resources_url: order_by
  counslr_website: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
  notes_vault_id: order_by
  privacy_policy_url: order_by
  stripe_client_id: order_by
  support_email: order_by
  terms_url: order_by
}

"input type for inserting object relation for remote table \"config\""
input config_obj_rel_insert_input {
  data: config_insert_input!
  on_conflict: config_on_conflict
}

"on conflict condition type for table \"config\""
input config_on_conflict {
  constraint: config_constraint!
  update_columns: [config_update_column!]!
  where: config_bool_exp
}

"ordering options when selecting data from \"config\""
input config_order_by {
  chat_now_frequency_hours: order_by
  chats_vault_id: order_by
  counselor_shift_capacity: order_by
  counslr_resources_url: order_by
  counslr_website: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
  notes_vault_id: order_by
  privacy_policy_url: order_by
  stripe_client_id: order_by
  support_email: order_by
  terms_url: order_by
}

"primary key columns input for table: \"config\""
input config_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"config\""
input config_set_input {
  chat_now_frequency_hours: Int
  chats_vault_id: uuid
  counselor_shift_capacity: Int
  counslr_resources_url: String
  counslr_website: String
  failed_attempts_count: Int
  id: Int
  max_backups_per_shift: Int
  max_schedule_weeks_threshold: Int
  max_shift_duration_hours: Int
  max_students_per_counselor_shift: Int
  min_shift_duration_hours: Int
  notes_submit_hours_threshold: Int
  notes_vault_id: uuid
  privacy_policy_url: String
  stripe_client_id: String
  support_email: String
  terms_url: String
}

"order by stddev() on columns of table \"config\""
input config_stddev_order_by {
  chat_now_frequency_hours: order_by
  counselor_shift_capacity: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
}

"order by stddev_pop() on columns of table \"config\""
input config_stddev_pop_order_by {
  chat_now_frequency_hours: order_by
  counselor_shift_capacity: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
}

"order by stddev_samp() on columns of table \"config\""
input config_stddev_samp_order_by {
  chat_now_frequency_hours: order_by
  counselor_shift_capacity: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
}

"order by sum() on columns of table \"config\""
input config_sum_order_by {
  chat_now_frequency_hours: order_by
  counselor_shift_capacity: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
}

"order by var_pop() on columns of table \"config\""
input config_var_pop_order_by {
  chat_now_frequency_hours: order_by
  counselor_shift_capacity: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
}

"order by var_samp() on columns of table \"config\""
input config_var_samp_order_by {
  chat_now_frequency_hours: order_by
  counselor_shift_capacity: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
}

"order by variance() on columns of table \"config\""
input config_variance_order_by {
  chat_now_frequency_hours: order_by
  counselor_shift_capacity: order_by
  failed_attempts_count: order_by
  id: order_by
  max_backups_per_shift: order_by
  max_schedule_weeks_threshold: order_by
  max_shift_duration_hours: order_by
  max_students_per_counselor_shift: order_by
  min_shift_duration_hours: order_by
  notes_submit_hours_threshold: order_by
}

"order by aggregate values of table \"counselor_enrollment\""
input counselor_enrollment_aggregate_order_by {
  avg: counselor_enrollment_avg_order_by
  count: order_by
  max: counselor_enrollment_max_order_by
  min: counselor_enrollment_min_order_by
  stddev: counselor_enrollment_stddev_order_by
  stddev_pop: counselor_enrollment_stddev_pop_order_by
  stddev_samp: counselor_enrollment_stddev_samp_order_by
  sum: counselor_enrollment_sum_order_by
  var_pop: counselor_enrollment_var_pop_order_by
  var_samp: counselor_enrollment_var_samp_order_by
  variance: counselor_enrollment_variance_order_by
}

"input type for inserting array relation for remote table \"counselor_enrollment\""
input counselor_enrollment_arr_rel_insert_input {
  data: [counselor_enrollment_insert_input!]!
  on_conflict: counselor_enrollment_on_conflict
}

"order by avg() on columns of table \"counselor_enrollment\""
input counselor_enrollment_avg_order_by {
  backup_position: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"Boolean expression to filter rows from the table \"counselor_enrollment\". All fields are combined with a logical 'AND'."
input counselor_enrollment_bool_exp {
  _and: [counselor_enrollment_bool_exp]
  _not: counselor_enrollment_bool_exp
  _or: [counselor_enrollment_bool_exp]
  backup: Boolean_comparison_exp
  backup_position: Int_comparison_exp
  counselor_id: uuid_comparison_exp
  id: Int_comparison_exp
  payout: payout_bool_exp
  sessions: session_bool_exp
  shift: shift_bool_exp
  shift_id: Int_comparison_exp
  shift_states: shift_states_bool_exp
  shift_states_id: Int_comparison_exp
  students_enrollment: student_enrollment_bool_exp
}

"input type for incrementing integer column in table \"counselor_enrollment\""
input counselor_enrollment_inc_input {
  backup_position: Int
  id: Int
  shift_id: Int
  shift_states_id: Int
}

"input type for inserting data into table \"counselor_enrollment\""
input counselor_enrollment_insert_input {
  backup: Boolean
  backup_position: Int
  counselor_id: uuid
  id: Int
  payout: payout_obj_rel_insert_input
  sessions: session_arr_rel_insert_input
  shift: shift_obj_rel_insert_input
  shift_id: Int
  shift_states: shift_states_arr_rel_insert_input
  shift_states_id: Int
  students_enrollment: student_enrollment_arr_rel_insert_input
}

"order by max() on columns of table \"counselor_enrollment\""
input counselor_enrollment_max_order_by {
  backup_position: order_by
  counselor_id: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"order by min() on columns of table \"counselor_enrollment\""
input counselor_enrollment_min_order_by {
  backup_position: order_by
  counselor_id: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"input type for inserting object relation for remote table \"counselor_enrollment\""
input counselor_enrollment_obj_rel_insert_input {
  data: counselor_enrollment_insert_input!
  on_conflict: counselor_enrollment_on_conflict
}

"on conflict condition type for table \"counselor_enrollment\""
input counselor_enrollment_on_conflict {
  constraint: counselor_enrollment_constraint!
  update_columns: [counselor_enrollment_update_column!]!
  where: counselor_enrollment_bool_exp
}

"ordering options when selecting data from \"counselor_enrollment\""
input counselor_enrollment_order_by {
  backup: order_by
  backup_position: order_by
  counselor_id: order_by
  id: order_by
  payout: payout_order_by
  sessions_aggregate: session_aggregate_order_by
  shift: shift_order_by
  shift_id: order_by
  shift_states_aggregate: shift_states_aggregate_order_by
  shift_states_id: order_by
  students_enrollment_aggregate: student_enrollment_aggregate_order_by
}

"primary key columns input for table: \"counselor_enrollment\""
input counselor_enrollment_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"counselor_enrollment\""
input counselor_enrollment_set_input {
  backup: Boolean
  backup_position: Int
  counselor_id: uuid
  id: Int
  shift_id: Int
  shift_states_id: Int
}

"order by stddev() on columns of table \"counselor_enrollment\""
input counselor_enrollment_stddev_order_by {
  backup_position: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"order by stddev_pop() on columns of table \"counselor_enrollment\""
input counselor_enrollment_stddev_pop_order_by {
  backup_position: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"order by stddev_samp() on columns of table \"counselor_enrollment\""
input counselor_enrollment_stddev_samp_order_by {
  backup_position: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"order by sum() on columns of table \"counselor_enrollment\""
input counselor_enrollment_sum_order_by {
  backup_position: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"order by var_pop() on columns of table \"counselor_enrollment\""
input counselor_enrollment_var_pop_order_by {
  backup_position: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"order by var_samp() on columns of table \"counselor_enrollment\""
input counselor_enrollment_var_samp_order_by {
  backup_position: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"order by variance() on columns of table \"counselor_enrollment\""
input counselor_enrollment_variance_order_by {
  backup_position: order_by
  id: order_by
  shift_id: order_by
  shift_states_id: order_by
}

"order by aggregate values of table \"counselor_note_config\""
input counselor_note_config_aggregate_order_by {
  avg: counselor_note_config_avg_order_by
  count: order_by
  max: counselor_note_config_max_order_by
  min: counselor_note_config_min_order_by
  stddev: counselor_note_config_stddev_order_by
  stddev_pop: counselor_note_config_stddev_pop_order_by
  stddev_samp: counselor_note_config_stddev_samp_order_by
  sum: counselor_note_config_sum_order_by
  var_pop: counselor_note_config_var_pop_order_by
  var_samp: counselor_note_config_var_samp_order_by
  variance: counselor_note_config_variance_order_by
}

"input type for inserting array relation for remote table \"counselor_note_config\""
input counselor_note_config_arr_rel_insert_input {
  data: [counselor_note_config_insert_input!]!
  on_conflict: counselor_note_config_on_conflict
}

"order by avg() on columns of table \"counselor_note_config\""
input counselor_note_config_avg_order_by {
  id: order_by
  max_length: order_by
  order: order_by
}

"Boolean expression to filter rows from the table \"counselor_note_config\". All fields are combined with a logical 'AND'."
input counselor_note_config_bool_exp {
  _and: [counselor_note_config_bool_exp]
  _not: counselor_note_config_bool_exp
  _or: [counselor_note_config_bool_exp]
  active: Boolean_comparison_exp
  custom_notes_options: custom_note_option_bool_exp
  id: Int_comparison_exp
  key: String_comparison_exp
  max_length: Int_comparison_exp
  order: Int_comparison_exp
  title: String_comparison_exp
  type: String_comparison_exp
}

"input type for incrementing integer column in table \"counselor_note_config\""
input counselor_note_config_inc_input {
  id: Int
  max_length: Int
  order: Int
}

"input type for inserting data into table \"counselor_note_config\""
input counselor_note_config_insert_input {
  active: Boolean
  custom_notes_options: custom_note_option_arr_rel_insert_input
  id: Int
  key: String
  max_length: Int
  order: Int
  title: String
  type: String
}

"order by max() on columns of table \"counselor_note_config\""
input counselor_note_config_max_order_by {
  id: order_by
  key: order_by
  max_length: order_by
  order: order_by
  title: order_by
  type: order_by
}

"order by min() on columns of table \"counselor_note_config\""
input counselor_note_config_min_order_by {
  id: order_by
  key: order_by
  max_length: order_by
  order: order_by
  title: order_by
  type: order_by
}

"input type for inserting object relation for remote table \"counselor_note_config\""
input counselor_note_config_obj_rel_insert_input {
  data: counselor_note_config_insert_input!
  on_conflict: counselor_note_config_on_conflict
}

"on conflict condition type for table \"counselor_note_config\""
input counselor_note_config_on_conflict {
  constraint: counselor_note_config_constraint!
  update_columns: [counselor_note_config_update_column!]!
  where: counselor_note_config_bool_exp
}

"ordering options when selecting data from \"counselor_note_config\""
input counselor_note_config_order_by {
  active: order_by
  custom_notes_options_aggregate: custom_note_option_aggregate_order_by
  id: order_by
  key: order_by
  max_length: order_by
  order: order_by
  title: order_by
  type: order_by
}

"primary key columns input for table: \"counselor_note_config\""
input counselor_note_config_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"counselor_note_config\""
input counselor_note_config_set_input {
  active: Boolean
  id: Int
  key: String
  max_length: Int
  order: Int
  title: String
  type: String
}

"order by stddev() on columns of table \"counselor_note_config\""
input counselor_note_config_stddev_order_by {
  id: order_by
  max_length: order_by
  order: order_by
}

"order by stddev_pop() on columns of table \"counselor_note_config\""
input counselor_note_config_stddev_pop_order_by {
  id: order_by
  max_length: order_by
  order: order_by
}

"order by stddev_samp() on columns of table \"counselor_note_config\""
input counselor_note_config_stddev_samp_order_by {
  id: order_by
  max_length: order_by
  order: order_by
}

"order by sum() on columns of table \"counselor_note_config\""
input counselor_note_config_sum_order_by {
  id: order_by
  max_length: order_by
  order: order_by
}

"order by var_pop() on columns of table \"counselor_note_config\""
input counselor_note_config_var_pop_order_by {
  id: order_by
  max_length: order_by
  order: order_by
}

"order by var_samp() on columns of table \"counselor_note_config\""
input counselor_note_config_var_samp_order_by {
  id: order_by
  max_length: order_by
  order: order_by
}

"order by variance() on columns of table \"counselor_note_config\""
input counselor_note_config_variance_order_by {
  id: order_by
  max_length: order_by
  order: order_by
}

"order by aggregate values of table \"counslr_request\""
input counslr_request_aggregate_order_by {
  avg: counslr_request_avg_order_by
  count: order_by
  max: counslr_request_max_order_by
  min: counslr_request_min_order_by
  stddev: counslr_request_stddev_order_by
  stddev_pop: counslr_request_stddev_pop_order_by
  stddev_samp: counslr_request_stddev_samp_order_by
  sum: counslr_request_sum_order_by
  var_pop: counslr_request_var_pop_order_by
  var_samp: counslr_request_var_samp_order_by
  variance: counslr_request_variance_order_by
}

"input type for inserting array relation for remote table \"counslr_request\""
input counslr_request_arr_rel_insert_input {
  data: [counslr_request_insert_input!]!
  on_conflict: counslr_request_on_conflict
}

"order by avg() on columns of table \"counslr_request\""
input counslr_request_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"counslr_request\". All fields are combined with a logical 'AND'."
input counslr_request_bool_exp {
  _and: [counslr_request_bool_exp]
  _not: counslr_request_bool_exp
  _or: [counslr_request_bool_exp]
  email: String_comparison_exp
  id: Int_comparison_exp
}

"input type for incrementing integer column in table \"counslr_request\""
input counslr_request_inc_input {
  id: Int
}

"input type for inserting data into table \"counslr_request\""
input counslr_request_insert_input {
  email: String
  id: Int
}

"order by max() on columns of table \"counslr_request\""
input counslr_request_max_order_by {
  email: order_by
  id: order_by
}

"order by min() on columns of table \"counslr_request\""
input counslr_request_min_order_by {
  email: order_by
  id: order_by
}

"input type for inserting object relation for remote table \"counslr_request\""
input counslr_request_obj_rel_insert_input {
  data: counslr_request_insert_input!
  on_conflict: counslr_request_on_conflict
}

"on conflict condition type for table \"counslr_request\""
input counslr_request_on_conflict {
  constraint: counslr_request_constraint!
  update_columns: [counslr_request_update_column!]!
  where: counslr_request_bool_exp
}

"ordering options when selecting data from \"counslr_request\""
input counslr_request_order_by {
  email: order_by
  id: order_by
}

"primary key columns input for table: \"counslr_request\""
input counslr_request_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"counslr_request\""
input counslr_request_set_input {
  email: String
  id: Int
}

"order by stddev() on columns of table \"counslr_request\""
input counslr_request_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"counslr_request\""
input counslr_request_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"counslr_request\""
input counslr_request_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"counslr_request\""
input counslr_request_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"counslr_request\""
input counslr_request_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"counslr_request\""
input counslr_request_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"counslr_request\""
input counslr_request_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"custom_note_option\""
input custom_note_option_aggregate_order_by {
  avg: custom_note_option_avg_order_by
  count: order_by
  max: custom_note_option_max_order_by
  min: custom_note_option_min_order_by
  stddev: custom_note_option_stddev_order_by
  stddev_pop: custom_note_option_stddev_pop_order_by
  stddev_samp: custom_note_option_stddev_samp_order_by
  sum: custom_note_option_sum_order_by
  var_pop: custom_note_option_var_pop_order_by
  var_samp: custom_note_option_var_samp_order_by
  variance: custom_note_option_variance_order_by
}

"input type for inserting array relation for remote table \"custom_note_option\""
input custom_note_option_arr_rel_insert_input {
  data: [custom_note_option_insert_input!]!
  on_conflict: custom_note_option_on_conflict
}

"order by avg() on columns of table \"custom_note_option\""
input custom_note_option_avg_order_by {
  counselor_note_config_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"custom_note_option\". All fields are combined with a logical 'AND'."
input custom_note_option_bool_exp {
  _and: [custom_note_option_bool_exp]
  _not: custom_note_option_bool_exp
  _or: [custom_note_option_bool_exp]
  active: Boolean_comparison_exp
  counselor_note_config_id: Int_comparison_exp
  id: Int_comparison_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"custom_note_option\""
input custom_note_option_inc_input {
  counselor_note_config_id: Int
  id: Int
}

"input type for inserting data into table \"custom_note_option\""
input custom_note_option_insert_input {
  active: Boolean
  counselor_note_config_id: Int
  id: Int
  value: String
}

"order by max() on columns of table \"custom_note_option\""
input custom_note_option_max_order_by {
  counselor_note_config_id: order_by
  id: order_by
  value: order_by
}

"order by min() on columns of table \"custom_note_option\""
input custom_note_option_min_order_by {
  counselor_note_config_id: order_by
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"custom_note_option\""
input custom_note_option_obj_rel_insert_input {
  data: custom_note_option_insert_input!
  on_conflict: custom_note_option_on_conflict
}

"on conflict condition type for table \"custom_note_option\""
input custom_note_option_on_conflict {
  constraint: custom_note_option_constraint!
  update_columns: [custom_note_option_update_column!]!
  where: custom_note_option_bool_exp
}

"ordering options when selecting data from \"custom_note_option\""
input custom_note_option_order_by {
  active: order_by
  counselor_note_config_id: order_by
  id: order_by
  value: order_by
}

"primary key columns input for table: \"custom_note_option\""
input custom_note_option_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"custom_note_option\""
input custom_note_option_set_input {
  active: Boolean
  counselor_note_config_id: Int
  id: Int
  value: String
}

"order by stddev() on columns of table \"custom_note_option\""
input custom_note_option_stddev_order_by {
  counselor_note_config_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"custom_note_option\""
input custom_note_option_stddev_pop_order_by {
  counselor_note_config_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"custom_note_option\""
input custom_note_option_stddev_samp_order_by {
  counselor_note_config_id: order_by
  id: order_by
}

"order by sum() on columns of table \"custom_note_option\""
input custom_note_option_sum_order_by {
  counselor_note_config_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"custom_note_option\""
input custom_note_option_var_pop_order_by {
  counselor_note_config_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"custom_note_option\""
input custom_note_option_var_samp_order_by {
  counselor_note_config_id: order_by
  id: order_by
}

"order by variance() on columns of table \"custom_note_option\""
input custom_note_option_variance_order_by {
  counselor_note_config_id: order_by
  id: order_by
}

"order by aggregate values of table \"device\""
input device_aggregate_order_by {
  avg: device_avg_order_by
  count: order_by
  max: device_max_order_by
  min: device_min_order_by
  stddev: device_stddev_order_by
  stddev_pop: device_stddev_pop_order_by
  stddev_samp: device_stddev_samp_order_by
  sum: device_sum_order_by
  var_pop: device_var_pop_order_by
  var_samp: device_var_samp_order_by
  variance: device_variance_order_by
}

"input type for inserting array relation for remote table \"device\""
input device_arr_rel_insert_input {
  data: [device_insert_input!]!
  on_conflict: device_on_conflict
}

"order by avg() on columns of table \"device\""
input device_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"device\". All fields are combined with a logical 'AND'."
input device_bool_exp {
  _and: [device_bool_exp]
  _not: device_bool_exp
  _or: [device_bool_exp]
  created_date: timestamptz_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  platform: String_comparison_exp
  token: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"input type for incrementing integer column in table \"device\""
input device_inc_input {
  id: Int
}

"input type for inserting data into table \"device\""
input device_insert_input {
  created_date: timestamptz
  id: Int
  name: String
  platform: String
  token: String
  user: user_obj_rel_insert_input
  user_id: uuid
}

"order by max() on columns of table \"device\""
input device_max_order_by {
  created_date: order_by
  id: order_by
  name: order_by
  platform: order_by
  token: order_by
  user_id: order_by
}

"order by min() on columns of table \"device\""
input device_min_order_by {
  created_date: order_by
  id: order_by
  name: order_by
  platform: order_by
  token: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"device\""
input device_obj_rel_insert_input {
  data: device_insert_input!
  on_conflict: device_on_conflict
}

"on conflict condition type for table \"device\""
input device_on_conflict {
  constraint: device_constraint!
  update_columns: [device_update_column!]!
  where: device_bool_exp
}

"ordering options when selecting data from \"device\""
input device_order_by {
  created_date: order_by
  id: order_by
  name: order_by
  platform: order_by
  token: order_by
  user: user_order_by
  user_id: order_by
}

"primary key columns input for table: \"device\""
input device_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"device\""
input device_set_input {
  created_date: timestamptz
  id: Int
  name: String
  platform: String
  token: String
  user_id: uuid
}

"order by stddev() on columns of table \"device\""
input device_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"device\""
input device_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"device\""
input device_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"device\""
input device_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"device\""
input device_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"device\""
input device_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"device\""
input device_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"emergency_service\""
input emergency_service_aggregate_order_by {
  avg: emergency_service_avg_order_by
  count: order_by
  max: emergency_service_max_order_by
  min: emergency_service_min_order_by
  stddev: emergency_service_stddev_order_by
  stddev_pop: emergency_service_stddev_pop_order_by
  stddev_samp: emergency_service_stddev_samp_order_by
  sum: emergency_service_sum_order_by
  var_pop: emergency_service_var_pop_order_by
  var_samp: emergency_service_var_samp_order_by
  variance: emergency_service_variance_order_by
}

"input type for inserting array relation for remote table \"emergency_service\""
input emergency_service_arr_rel_insert_input {
  data: [emergency_service_insert_input!]!
  on_conflict: emergency_service_on_conflict
}

"order by avg() on columns of table \"emergency_service\""
input emergency_service_avg_order_by {
  id: order_by
  school_id: order_by
}

"Boolean expression to filter rows from the table \"emergency_service\". All fields are combined with a logical 'AND'."
input emergency_service_bool_exp {
  _and: [emergency_service_bool_exp]
  _not: emergency_service_bool_exp
  _or: [emergency_service_bool_exp]
  id: Int_comparison_exp
  name: String_comparison_exp
  phone: String_comparison_exp
  school: school_bool_exp
  school_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"emergency_service\""
input emergency_service_inc_input {
  id: Int
  school_id: Int
}

"input type for inserting data into table \"emergency_service\""
input emergency_service_insert_input {
  id: Int
  name: String
  phone: String
  school: school_obj_rel_insert_input
  school_id: Int
}

"order by max() on columns of table \"emergency_service\""
input emergency_service_max_order_by {
  id: order_by
  name: order_by
  phone: order_by
  school_id: order_by
}

"order by min() on columns of table \"emergency_service\""
input emergency_service_min_order_by {
  id: order_by
  name: order_by
  phone: order_by
  school_id: order_by
}

"input type for inserting object relation for remote table \"emergency_service\""
input emergency_service_obj_rel_insert_input {
  data: emergency_service_insert_input!
  on_conflict: emergency_service_on_conflict
}

"on conflict condition type for table \"emergency_service\""
input emergency_service_on_conflict {
  constraint: emergency_service_constraint!
  update_columns: [emergency_service_update_column!]!
  where: emergency_service_bool_exp
}

"ordering options when selecting data from \"emergency_service\""
input emergency_service_order_by {
  id: order_by
  name: order_by
  phone: order_by
  school: school_order_by
  school_id: order_by
}

"primary key columns input for table: \"emergency_service\""
input emergency_service_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"emergency_service\""
input emergency_service_set_input {
  id: Int
  name: String
  phone: String
  school_id: Int
}

"order by stddev() on columns of table \"emergency_service\""
input emergency_service_stddev_order_by {
  id: order_by
  school_id: order_by
}

"order by stddev_pop() on columns of table \"emergency_service\""
input emergency_service_stddev_pop_order_by {
  id: order_by
  school_id: order_by
}

"order by stddev_samp() on columns of table \"emergency_service\""
input emergency_service_stddev_samp_order_by {
  id: order_by
  school_id: order_by
}

"order by sum() on columns of table \"emergency_service\""
input emergency_service_sum_order_by {
  id: order_by
  school_id: order_by
}

"order by var_pop() on columns of table \"emergency_service\""
input emergency_service_var_pop_order_by {
  id: order_by
  school_id: order_by
}

"order by var_samp() on columns of table \"emergency_service\""
input emergency_service_var_samp_order_by {
  id: order_by
  school_id: order_by
}

"order by variance() on columns of table \"emergency_service\""
input emergency_service_variance_order_by {
  id: order_by
  school_id: order_by
}

"order by aggregate values of table \"ethnicity\""
input ethnicity_aggregate_order_by {
  avg: ethnicity_avg_order_by
  count: order_by
  max: ethnicity_max_order_by
  min: ethnicity_min_order_by
  stddev: ethnicity_stddev_order_by
  stddev_pop: ethnicity_stddev_pop_order_by
  stddev_samp: ethnicity_stddev_samp_order_by
  sum: ethnicity_sum_order_by
  var_pop: ethnicity_var_pop_order_by
  var_samp: ethnicity_var_samp_order_by
  variance: ethnicity_variance_order_by
}

"input type for inserting array relation for remote table \"ethnicity\""
input ethnicity_arr_rel_insert_input {
  data: [ethnicity_insert_input!]!
  on_conflict: ethnicity_on_conflict
}

"order by avg() on columns of table \"ethnicity\""
input ethnicity_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"ethnicity\". All fields are combined with a logical 'AND'."
input ethnicity_bool_exp {
  _and: [ethnicity_bool_exp]
  _not: ethnicity_bool_exp
  _or: [ethnicity_bool_exp]
  id: Int_comparison_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"ethnicity\""
input ethnicity_inc_input {
  id: Int
}

"input type for inserting data into table \"ethnicity\""
input ethnicity_insert_input {
  id: Int
  value: String
}

"order by max() on columns of table \"ethnicity\""
input ethnicity_max_order_by {
  id: order_by
  value: order_by
}

"order by min() on columns of table \"ethnicity\""
input ethnicity_min_order_by {
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"ethnicity\""
input ethnicity_obj_rel_insert_input {
  data: ethnicity_insert_input!
  on_conflict: ethnicity_on_conflict
}

"on conflict condition type for table \"ethnicity\""
input ethnicity_on_conflict {
  constraint: ethnicity_constraint!
  update_columns: [ethnicity_update_column!]!
  where: ethnicity_bool_exp
}

"ordering options when selecting data from \"ethnicity\""
input ethnicity_order_by {
  id: order_by
  value: order_by
}

"primary key columns input for table: \"ethnicity\""
input ethnicity_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"ethnicity\""
input ethnicity_set_input {
  id: Int
  value: String
}

"order by stddev() on columns of table \"ethnicity\""
input ethnicity_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"ethnicity\""
input ethnicity_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"ethnicity\""
input ethnicity_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"ethnicity\""
input ethnicity_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"ethnicity\""
input ethnicity_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"ethnicity\""
input ethnicity_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"ethnicity\""
input ethnicity_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"gender\""
input gender_aggregate_order_by {
  avg: gender_avg_order_by
  count: order_by
  max: gender_max_order_by
  min: gender_min_order_by
  stddev: gender_stddev_order_by
  stddev_pop: gender_stddev_pop_order_by
  stddev_samp: gender_stddev_samp_order_by
  sum: gender_sum_order_by
  var_pop: gender_var_pop_order_by
  var_samp: gender_var_samp_order_by
  variance: gender_variance_order_by
}

"input type for inserting array relation for remote table \"gender\""
input gender_arr_rel_insert_input {
  data: [gender_insert_input!]!
  on_conflict: gender_on_conflict
}

"order by avg() on columns of table \"gender\""
input gender_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"gender\". All fields are combined with a logical 'AND'."
input gender_bool_exp {
  _and: [gender_bool_exp]
  _not: gender_bool_exp
  _or: [gender_bool_exp]
  id: Int_comparison_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"gender\""
input gender_inc_input {
  id: Int
}

"input type for inserting data into table \"gender\""
input gender_insert_input {
  id: Int
  value: String
}

"order by max() on columns of table \"gender\""
input gender_max_order_by {
  id: order_by
  value: order_by
}

"order by min() on columns of table \"gender\""
input gender_min_order_by {
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"gender\""
input gender_obj_rel_insert_input {
  data: gender_insert_input!
  on_conflict: gender_on_conflict
}

"on conflict condition type for table \"gender\""
input gender_on_conflict {
  constraint: gender_constraint!
  update_columns: [gender_update_column!]!
  where: gender_bool_exp
}

"ordering options when selecting data from \"gender\""
input gender_order_by {
  id: order_by
  value: order_by
}

"primary key columns input for table: \"gender\""
input gender_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"gender\""
input gender_set_input {
  id: Int
  value: String
}

"order by stddev() on columns of table \"gender\""
input gender_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"gender\""
input gender_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"gender\""
input gender_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"gender\""
input gender_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"gender\""
input gender_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"gender\""
input gender_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"gender\""
input gender_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"identity\""
input identity_aggregate_order_by {
  avg: identity_avg_order_by
  count: order_by
  max: identity_max_order_by
  min: identity_min_order_by
  stddev: identity_stddev_order_by
  stddev_pop: identity_stddev_pop_order_by
  stddev_samp: identity_stddev_samp_order_by
  sum: identity_sum_order_by
  var_pop: identity_var_pop_order_by
  var_samp: identity_var_samp_order_by
  variance: identity_variance_order_by
}

"input type for inserting array relation for remote table \"identity\""
input identity_arr_rel_insert_input {
  data: [identity_insert_input!]!
  on_conflict: identity_on_conflict
}

"order by avg() on columns of table \"identity\""
input identity_avg_order_by {
  school_id: order_by
}

"Boolean expression to filter rows from the table \"identity\". All fields are combined with a logical 'AND'."
input identity_bool_exp {
  _and: [identity_bool_exp]
  _not: identity_bool_exp
  _or: [identity_bool_exp]
  id: String_comparison_exp
  school: school_bool_exp
  school_id: Int_comparison_exp
  user: user_bool_exp
}

"input type for incrementing integer column in table \"identity\""
input identity_inc_input {
  school_id: Int
}

"input type for inserting data into table \"identity\""
input identity_insert_input {
  id: String
  school: school_obj_rel_insert_input
  school_id: Int
  user: user_obj_rel_insert_input
}

"order by max() on columns of table \"identity\""
input identity_max_order_by {
  id: order_by
  school_id: order_by
}

"order by min() on columns of table \"identity\""
input identity_min_order_by {
  id: order_by
  school_id: order_by
}

"input type for inserting object relation for remote table \"identity\""
input identity_obj_rel_insert_input {
  data: identity_insert_input!
  on_conflict: identity_on_conflict
}

"on conflict condition type for table \"identity\""
input identity_on_conflict {
  constraint: identity_constraint!
  update_columns: [identity_update_column!]!
  where: identity_bool_exp
}

"ordering options when selecting data from \"identity\""
input identity_order_by {
  id: order_by
  school: school_order_by
  school_id: order_by
  user: user_order_by
}

"primary key columns input for table: \"identity\""
input identity_pk_columns_input {
  id: String!
}

"input type for updating data in table \"identity\""
input identity_set_input {
  id: String
  school_id: Int
}

"order by stddev() on columns of table \"identity\""
input identity_stddev_order_by {
  school_id: order_by
}

"order by stddev_pop() on columns of table \"identity\""
input identity_stddev_pop_order_by {
  school_id: order_by
}

"order by stddev_samp() on columns of table \"identity\""
input identity_stddev_samp_order_by {
  school_id: order_by
}

"order by sum() on columns of table \"identity\""
input identity_sum_order_by {
  school_id: order_by
}

"order by var_pop() on columns of table \"identity\""
input identity_var_pop_order_by {
  school_id: order_by
}

"order by var_samp() on columns of table \"identity\""
input identity_var_samp_order_by {
  school_id: order_by
}

"order by variance() on columns of table \"identity\""
input identity_variance_order_by {
  school_id: order_by
}

"expression to compare columns of type numeric. All fields are combined with logical 'AND'."
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"order by aggregate values of table \"payment_plan\""
input payment_plan_aggregate_order_by {
  avg: payment_plan_avg_order_by
  count: order_by
  max: payment_plan_max_order_by
  min: payment_plan_min_order_by
  stddev: payment_plan_stddev_order_by
  stddev_pop: payment_plan_stddev_pop_order_by
  stddev_samp: payment_plan_stddev_samp_order_by
  sum: payment_plan_sum_order_by
  var_pop: payment_plan_var_pop_order_by
  var_samp: payment_plan_var_samp_order_by
  variance: payment_plan_variance_order_by
}

"input type for inserting array relation for remote table \"payment_plan\""
input payment_plan_arr_rel_insert_input {
  data: [payment_plan_insert_input!]!
  on_conflict: payment_plan_on_conflict
}

"order by avg() on columns of table \"payment_plan\""
input payment_plan_avg_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
}

"Boolean expression to filter rows from the table \"payment_plan\". All fields are combined with a logical 'AND'."
input payment_plan_bool_exp {
  _and: [payment_plan_bool_exp]
  _not: payment_plan_bool_exp
  _or: [payment_plan_bool_exp]
  id: Int_comparison_exp
  payouts: payout_bool_exp
  session_hourly_rate: numeric_comparison_exp
  shift_hourly_rate: numeric_comparison_exp
  start_date: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"payment_plan\""
input payment_plan_inc_input {
  id: Int
  session_hourly_rate: numeric
  shift_hourly_rate: numeric
}

"input type for inserting data into table \"payment_plan\""
input payment_plan_insert_input {
  id: Int
  payouts: payout_arr_rel_insert_input
  session_hourly_rate: numeric
  shift_hourly_rate: numeric
  start_date: timestamptz
}

"order by max() on columns of table \"payment_plan\""
input payment_plan_max_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
  start_date: order_by
}

"order by min() on columns of table \"payment_plan\""
input payment_plan_min_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
  start_date: order_by
}

"input type for inserting object relation for remote table \"payment_plan\""
input payment_plan_obj_rel_insert_input {
  data: payment_plan_insert_input!
  on_conflict: payment_plan_on_conflict
}

"on conflict condition type for table \"payment_plan\""
input payment_plan_on_conflict {
  constraint: payment_plan_constraint!
  update_columns: [payment_plan_update_column!]!
  where: payment_plan_bool_exp
}

"ordering options when selecting data from \"payment_plan\""
input payment_plan_order_by {
  id: order_by
  payouts_aggregate: payout_aggregate_order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
  start_date: order_by
}

"primary key columns input for table: \"payment_plan\""
input payment_plan_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"payment_plan\""
input payment_plan_set_input {
  id: Int
  session_hourly_rate: numeric
  shift_hourly_rate: numeric
  start_date: timestamptz
}

"order by stddev() on columns of table \"payment_plan\""
input payment_plan_stddev_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
}

"order by stddev_pop() on columns of table \"payment_plan\""
input payment_plan_stddev_pop_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
}

"order by stddev_samp() on columns of table \"payment_plan\""
input payment_plan_stddev_samp_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
}

"order by sum() on columns of table \"payment_plan\""
input payment_plan_sum_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
}

"order by var_pop() on columns of table \"payment_plan\""
input payment_plan_var_pop_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
}

"order by var_samp() on columns of table \"payment_plan\""
input payment_plan_var_samp_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
}

"order by variance() on columns of table \"payment_plan\""
input payment_plan_variance_order_by {
  id: order_by
  session_hourly_rate: order_by
  shift_hourly_rate: order_by
}

"order by aggregate values of table \"payout\""
input payout_aggregate_order_by {
  avg: payout_avg_order_by
  count: order_by
  max: payout_max_order_by
  min: payout_min_order_by
  stddev: payout_stddev_order_by
  stddev_pop: payout_stddev_pop_order_by
  stddev_samp: payout_stddev_samp_order_by
  sum: payout_sum_order_by
  var_pop: payout_var_pop_order_by
  var_samp: payout_var_samp_order_by
  variance: payout_variance_order_by
}

"input type for inserting array relation for remote table \"payout\""
input payout_arr_rel_insert_input {
  data: [payout_insert_input!]!
  on_conflict: payout_on_conflict
}

"order by avg() on columns of table \"payout\""
input payout_avg_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"Boolean expression to filter rows from the table \"payout\". All fields are combined with a logical 'AND'."
input payout_bool_exp {
  _and: [payout_bool_exp]
  _not: payout_bool_exp
  _or: [payout_bool_exp]
  amount: numeric_comparison_exp
  counselor_enrollment: counselor_enrollment_bool_exp
  counselor_enrollment_id: Int_comparison_exp
  date: timestamptz_comparison_exp
  id: Int_comparison_exp
  payment_plan_id: Int_comparison_exp
  payments_plan: payment_plan_bool_exp
  payout_status: payout_status_bool_exp
  payout_status_id: Int_comparison_exp
  session: session_bool_exp
  session_id: Int_comparison_exp
  transaction_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"payout\""
input payout_inc_input {
  amount: numeric
  counselor_enrollment_id: Int
  id: Int
  payment_plan_id: Int
  payout_status_id: Int
  session_id: Int
  transaction_id: Int
}

"input type for inserting data into table \"payout\""
input payout_insert_input {
  amount: numeric
  counselor_enrollment: counselor_enrollment_obj_rel_insert_input
  counselor_enrollment_id: Int
  date: timestamptz
  id: Int
  payment_plan_id: Int
  payments_plan: payment_plan_arr_rel_insert_input
  payout_status: payout_status_arr_rel_insert_input
  payout_status_id: Int
  session: session_obj_rel_insert_input
  session_id: Int
  transaction_id: Int
}

"order by max() on columns of table \"payout\""
input payout_max_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  date: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"order by min() on columns of table \"payout\""
input payout_min_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  date: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"input type for inserting object relation for remote table \"payout\""
input payout_obj_rel_insert_input {
  data: payout_insert_input!
  on_conflict: payout_on_conflict
}

"on conflict condition type for table \"payout\""
input payout_on_conflict {
  constraint: payout_constraint!
  update_columns: [payout_update_column!]!
  where: payout_bool_exp
}

"ordering options when selecting data from \"payout\""
input payout_order_by {
  amount: order_by
  counselor_enrollment: counselor_enrollment_order_by
  counselor_enrollment_id: order_by
  date: order_by
  id: order_by
  payment_plan_id: order_by
  payments_plan_aggregate: payment_plan_aggregate_order_by
  payout_status_aggregate: payout_status_aggregate_order_by
  payout_status_id: order_by
  session: session_order_by
  session_id: order_by
  transaction_id: order_by
}

"primary key columns input for table: \"payout\""
input payout_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"payout\""
input payout_set_input {
  amount: numeric
  counselor_enrollment_id: Int
  date: timestamptz
  id: Int
  payment_plan_id: Int
  payout_status_id: Int
  session_id: Int
  transaction_id: Int
}

"order by aggregate values of table \"payout_status\""
input payout_status_aggregate_order_by {
  avg: payout_status_avg_order_by
  count: order_by
  max: payout_status_max_order_by
  min: payout_status_min_order_by
  stddev: payout_status_stddev_order_by
  stddev_pop: payout_status_stddev_pop_order_by
  stddev_samp: payout_status_stddev_samp_order_by
  sum: payout_status_sum_order_by
  var_pop: payout_status_var_pop_order_by
  var_samp: payout_status_var_samp_order_by
  variance: payout_status_variance_order_by
}

"input type for inserting array relation for remote table \"payout_status\""
input payout_status_arr_rel_insert_input {
  data: [payout_status_insert_input!]!
  on_conflict: payout_status_on_conflict
}

"order by avg() on columns of table \"payout_status\""
input payout_status_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"payout_status\". All fields are combined with a logical 'AND'."
input payout_status_bool_exp {
  _and: [payout_status_bool_exp]
  _not: payout_status_bool_exp
  _or: [payout_status_bool_exp]
  id: Int_comparison_exp
  payouts: payout_bool_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"payout_status\""
input payout_status_inc_input {
  id: Int
}

"input type for inserting data into table \"payout_status\""
input payout_status_insert_input {
  id: Int
  payouts: payout_arr_rel_insert_input
  value: String
}

"order by max() on columns of table \"payout_status\""
input payout_status_max_order_by {
  id: order_by
  value: order_by
}

"order by min() on columns of table \"payout_status\""
input payout_status_min_order_by {
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"payout_status\""
input payout_status_obj_rel_insert_input {
  data: payout_status_insert_input!
  on_conflict: payout_status_on_conflict
}

"on conflict condition type for table \"payout_status\""
input payout_status_on_conflict {
  constraint: payout_status_constraint!
  update_columns: [payout_status_update_column!]!
  where: payout_status_bool_exp
}

"ordering options when selecting data from \"payout_status\""
input payout_status_order_by {
  id: order_by
  payouts_aggregate: payout_aggregate_order_by
  value: order_by
}

"primary key columns input for table: \"payout_status\""
input payout_status_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"payout_status\""
input payout_status_set_input {
  id: Int
  value: String
}

"order by stddev() on columns of table \"payout_status\""
input payout_status_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"payout_status\""
input payout_status_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"payout_status\""
input payout_status_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"payout_status\""
input payout_status_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"payout_status\""
input payout_status_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"payout_status\""
input payout_status_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"payout_status\""
input payout_status_variance_order_by {
  id: order_by
}

"order by stddev() on columns of table \"payout\""
input payout_stddev_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"order by stddev_pop() on columns of table \"payout\""
input payout_stddev_pop_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"order by stddev_samp() on columns of table \"payout\""
input payout_stddev_samp_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"order by sum() on columns of table \"payout\""
input payout_sum_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"order by var_pop() on columns of table \"payout\""
input payout_var_pop_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"order by var_samp() on columns of table \"payout\""
input payout_var_samp_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"order by variance() on columns of table \"payout\""
input payout_variance_order_by {
  amount: order_by
  counselor_enrollment_id: order_by
  id: order_by
  payment_plan_id: order_by
  payout_status_id: order_by
  session_id: order_by
  transaction_id: order_by
}

"order by aggregate values of table \"plan\""
input plan_aggregate_order_by {
  avg: plan_avg_order_by
  count: order_by
  max: plan_max_order_by
  min: plan_min_order_by
  stddev: plan_stddev_order_by
  stddev_pop: plan_stddev_pop_order_by
  stddev_samp: plan_stddev_samp_order_by
  sum: plan_sum_order_by
  var_pop: plan_var_pop_order_by
  var_samp: plan_var_samp_order_by
  variance: plan_variance_order_by
}

"input type for inserting array relation for remote table \"plan\""
input plan_arr_rel_insert_input {
  data: [plan_insert_input!]!
  on_conflict: plan_on_conflict
}

"order by avg() on columns of table \"plan\""
input plan_avg_order_by {
  id: order_by
  sessions_count: order_by
}

"Boolean expression to filter rows from the table \"plan\". All fields are combined with a logical 'AND'."
input plan_bool_exp {
  _and: [plan_bool_exp]
  _not: plan_bool_exp
  _or: [plan_bool_exp]
  frequency: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  schools: school_bool_exp
  sessions_count: Int_comparison_exp
}

"input type for incrementing integer column in table \"plan\""
input plan_inc_input {
  id: Int
  sessions_count: Int
}

"input type for inserting data into table \"plan\""
input plan_insert_input {
  frequency: String
  id: Int
  name: String
  schools: school_arr_rel_insert_input
  sessions_count: Int
}

"order by max() on columns of table \"plan\""
input plan_max_order_by {
  frequency: order_by
  id: order_by
  name: order_by
  sessions_count: order_by
}

"order by min() on columns of table \"plan\""
input plan_min_order_by {
  frequency: order_by
  id: order_by
  name: order_by
  sessions_count: order_by
}

"input type for inserting object relation for remote table \"plan\""
input plan_obj_rel_insert_input {
  data: plan_insert_input!
  on_conflict: plan_on_conflict
}

"on conflict condition type for table \"plan\""
input plan_on_conflict {
  constraint: plan_constraint!
  update_columns: [plan_update_column!]!
  where: plan_bool_exp
}

"ordering options when selecting data from \"plan\""
input plan_order_by {
  frequency: order_by
  id: order_by
  name: order_by
  schools_aggregate: school_aggregate_order_by
  sessions_count: order_by
}

"primary key columns input for table: \"plan\""
input plan_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"plan\""
input plan_set_input {
  frequency: String
  id: Int
  name: String
  sessions_count: Int
}

"order by stddev() on columns of table \"plan\""
input plan_stddev_order_by {
  id: order_by
  sessions_count: order_by
}

"order by stddev_pop() on columns of table \"plan\""
input plan_stddev_pop_order_by {
  id: order_by
  sessions_count: order_by
}

"order by stddev_samp() on columns of table \"plan\""
input plan_stddev_samp_order_by {
  id: order_by
  sessions_count: order_by
}

"order by sum() on columns of table \"plan\""
input plan_sum_order_by {
  id: order_by
  sessions_count: order_by
}

"order by var_pop() on columns of table \"plan\""
input plan_var_pop_order_by {
  id: order_by
  sessions_count: order_by
}

"order by var_samp() on columns of table \"plan\""
input plan_var_samp_order_by {
  id: order_by
  sessions_count: order_by
}

"order by variance() on columns of table \"plan\""
input plan_variance_order_by {
  id: order_by
  sessions_count: order_by
}

"order by aggregate values of table \"school\""
input school_aggregate_order_by {
  avg: school_avg_order_by
  count: order_by
  max: school_max_order_by
  min: school_min_order_by
  stddev: school_stddev_order_by
  stddev_pop: school_stddev_pop_order_by
  stddev_samp: school_stddev_samp_order_by
  sum: school_sum_order_by
  var_pop: school_var_pop_order_by
  var_samp: school_var_samp_order_by
  variance: school_variance_order_by
}

"input type for inserting array relation for remote table \"school\""
input school_arr_rel_insert_input {
  data: [school_insert_input!]!
  on_conflict: school_on_conflict
}

"order by avg() on columns of table \"school\""
input school_avg_order_by {
  id: order_by
  plan_id: order_by
  state_id: order_by
}

"Boolean expression to filter rows from the table \"school\". All fields are combined with a logical 'AND'."
input school_bool_exp {
  _and: [school_bool_exp]
  _not: school_bool_exp
  _or: [school_bool_exp]
  address: String_comparison_exp
  emergency_services: emergency_service_bool_exp
  enabled: Boolean_comparison_exp
  id: Int_comparison_exp
  issuer: String_comparison_exp
  logo: String_comparison_exp
  name: String_comparison_exp
  phone: String_comparison_exp
  plan: plan_bool_exp
  plan_id: Int_comparison_exp
  resources: String_comparison_exp
  school_users: user_bool_exp
  state: state_bool_exp
  state_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"school\""
input school_inc_input {
  id: Int
  plan_id: Int
  state_id: Int
}

"input type for inserting data into table \"school\""
input school_insert_input {
  address: String
  emergency_services: emergency_service_arr_rel_insert_input
  enabled: Boolean
  id: Int
  issuer: String
  logo: String
  name: String
  phone: String
  plan: plan_obj_rel_insert_input
  plan_id: Int
  resources: String
  school_users: user_arr_rel_insert_input
  state: state_obj_rel_insert_input
  state_id: Int
}

"order by max() on columns of table \"school\""
input school_max_order_by {
  address: order_by
  id: order_by
  issuer: order_by
  logo: order_by
  name: order_by
  phone: order_by
  plan_id: order_by
  resources: order_by
  state_id: order_by
}

"order by min() on columns of table \"school\""
input school_min_order_by {
  address: order_by
  id: order_by
  issuer: order_by
  logo: order_by
  name: order_by
  phone: order_by
  plan_id: order_by
  resources: order_by
  state_id: order_by
}

"input type for inserting object relation for remote table \"school\""
input school_obj_rel_insert_input {
  data: school_insert_input!
  on_conflict: school_on_conflict
}

"on conflict condition type for table \"school\""
input school_on_conflict {
  constraint: school_constraint!
  update_columns: [school_update_column!]!
  where: school_bool_exp
}

"ordering options when selecting data from \"school\""
input school_order_by {
  address: order_by
  emergency_services_aggregate: emergency_service_aggregate_order_by
  enabled: order_by
  id: order_by
  issuer: order_by
  logo: order_by
  name: order_by
  phone: order_by
  plan: plan_order_by
  plan_id: order_by
  resources: order_by
  school_users_aggregate: user_aggregate_order_by
  state: state_order_by
  state_id: order_by
}

"primary key columns input for table: \"school\""
input school_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"school\""
input school_set_input {
  address: String
  enabled: Boolean
  id: Int
  issuer: String
  logo: String
  name: String
  phone: String
  plan_id: Int
  resources: String
  state_id: Int
}

"order by stddev() on columns of table \"school\""
input school_stddev_order_by {
  id: order_by
  plan_id: order_by
  state_id: order_by
}

"order by stddev_pop() on columns of table \"school\""
input school_stddev_pop_order_by {
  id: order_by
  plan_id: order_by
  state_id: order_by
}

"order by stddev_samp() on columns of table \"school\""
input school_stddev_samp_order_by {
  id: order_by
  plan_id: order_by
  state_id: order_by
}

"order by sum() on columns of table \"school\""
input school_sum_order_by {
  id: order_by
  plan_id: order_by
  state_id: order_by
}

"order by var_pop() on columns of table \"school\""
input school_var_pop_order_by {
  id: order_by
  plan_id: order_by
  state_id: order_by
}

"order by var_samp() on columns of table \"school\""
input school_var_samp_order_by {
  id: order_by
  plan_id: order_by
  state_id: order_by
}

"order by variance() on columns of table \"school\""
input school_variance_order_by {
  id: order_by
  plan_id: order_by
  state_id: order_by
}

"order by aggregate values of table \"session\""
input session_aggregate_order_by {
  avg: session_avg_order_by
  count: order_by
  max: session_max_order_by
  min: session_min_order_by
  stddev: session_stddev_order_by
  stddev_pop: session_stddev_pop_order_by
  stddev_samp: session_stddev_samp_order_by
  sum: session_sum_order_by
  var_pop: session_var_pop_order_by
  var_samp: session_var_samp_order_by
  variance: session_variance_order_by
}

"input type for inserting array relation for remote table \"session\""
input session_arr_rel_insert_input {
  data: [session_insert_input!]!
  on_conflict: session_on_conflict
}

"order by avg() on columns of table \"session\""
input session_avg_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  session_status_id: order_by
  session_type_id: order_by
  student_enrollment_id: order_by
}

"Boolean expression to filter rows from the table \"session\". All fields are combined with a logical 'AND'."
input session_bool_exp {
  _and: [session_bool_exp]
  _not: session_bool_exp
  _or: [session_bool_exp]
  cancellation: session_cancellation_bool_exp
  chat_channel_id: String_comparison_exp
  chat_document_id: uuid_comparison_exp
  cleanup_session: Boolean_comparison_exp
  counselor: user_bool_exp
  counselor_enrollment: counselor_enrollment_bool_exp
  counselor_enrollment_id: Int_comparison_exp
  counselor_id: uuid_comparison_exp
  description: String_comparison_exp
  end_date: timestamptz_comparison_exp
  id: Int_comparison_exp
  note_document_id: uuid_comparison_exp
  payouts: payout_bool_exp
  scheduled_end_date: timestamptz_comparison_exp
  scheduled_start_date: timestamptz_comparison_exp
  session_feedback: session_feedback_bool_exp
  session_reminder_1m: Boolean_comparison_exp
  session_reminder_30m: Boolean_comparison_exp
  session_status: session_status_bool_exp
  session_status_id: Int_comparison_exp
  session_topics: session_topic_bool_exp
  session_type: session_type_bool_exp
  session_type_id: Int_comparison_exp
  start_date: timestamptz_comparison_exp
  student: user_bool_exp
  student_enrollment: student_enrollment_bool_exp
  student_enrollment_id: Int_comparison_exp
  student_id: uuid_comparison_exp
}

"order by aggregate values of table \"session_cancellation\""
input session_cancellation_aggregate_order_by {
  avg: session_cancellation_avg_order_by
  count: order_by
  max: session_cancellation_max_order_by
  min: session_cancellation_min_order_by
  stddev: session_cancellation_stddev_order_by
  stddev_pop: session_cancellation_stddev_pop_order_by
  stddev_samp: session_cancellation_stddev_samp_order_by
  sum: session_cancellation_sum_order_by
  var_pop: session_cancellation_var_pop_order_by
  var_samp: session_cancellation_var_samp_order_by
  variance: session_cancellation_variance_order_by
}

"input type for inserting array relation for remote table \"session_cancellation\""
input session_cancellation_arr_rel_insert_input {
  data: [session_cancellation_insert_input!]!
  on_conflict: session_cancellation_on_conflict
}

"order by avg() on columns of table \"session_cancellation\""
input session_cancellation_avg_order_by {
  id: order_by
  session_id: order_by
}

"Boolean expression to filter rows from the table \"session_cancellation\". All fields are combined with a logical 'AND'."
input session_cancellation_bool_exp {
  _and: [session_cancellation_bool_exp]
  _not: session_cancellation_bool_exp
  _or: [session_cancellation_bool_exp]
  cancellation_date_time: timestamptz_comparison_exp
  cancellation_extra_details: String_comparison_exp
  cancellation_reason: String_comparison_exp
  id: Int_comparison_exp
  session: session_bool_exp
  session_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"session_cancellation\""
input session_cancellation_inc_input {
  id: Int
  session_id: Int
}

"input type for inserting data into table \"session_cancellation\""
input session_cancellation_insert_input {
  cancellation_date_time: timestamptz
  cancellation_extra_details: String
  cancellation_reason: String
  id: Int
  session: session_obj_rel_insert_input
  session_id: Int
}

"order by max() on columns of table \"session_cancellation\""
input session_cancellation_max_order_by {
  cancellation_date_time: order_by
  cancellation_extra_details: order_by
  cancellation_reason: order_by
  id: order_by
  session_id: order_by
}

"order by min() on columns of table \"session_cancellation\""
input session_cancellation_min_order_by {
  cancellation_date_time: order_by
  cancellation_extra_details: order_by
  cancellation_reason: order_by
  id: order_by
  session_id: order_by
}

"input type for inserting object relation for remote table \"session_cancellation\""
input session_cancellation_obj_rel_insert_input {
  data: session_cancellation_insert_input!
  on_conflict: session_cancellation_on_conflict
}

"on conflict condition type for table \"session_cancellation\""
input session_cancellation_on_conflict {
  constraint: session_cancellation_constraint!
  update_columns: [session_cancellation_update_column!]!
  where: session_cancellation_bool_exp
}

"ordering options when selecting data from \"session_cancellation\""
input session_cancellation_order_by {
  cancellation_date_time: order_by
  cancellation_extra_details: order_by
  cancellation_reason: order_by
  id: order_by
  session: session_order_by
  session_id: order_by
}

"primary key columns input for table: \"session_cancellation\""
input session_cancellation_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"session_cancellation\""
input session_cancellation_set_input {
  cancellation_date_time: timestamptz
  cancellation_extra_details: String
  cancellation_reason: String
  id: Int
  session_id: Int
}

"order by stddev() on columns of table \"session_cancellation\""
input session_cancellation_stddev_order_by {
  id: order_by
  session_id: order_by
}

"order by stddev_pop() on columns of table \"session_cancellation\""
input session_cancellation_stddev_pop_order_by {
  id: order_by
  session_id: order_by
}

"order by stddev_samp() on columns of table \"session_cancellation\""
input session_cancellation_stddev_samp_order_by {
  id: order_by
  session_id: order_by
}

"order by sum() on columns of table \"session_cancellation\""
input session_cancellation_sum_order_by {
  id: order_by
  session_id: order_by
}

"order by var_pop() on columns of table \"session_cancellation\""
input session_cancellation_var_pop_order_by {
  id: order_by
  session_id: order_by
}

"order by var_samp() on columns of table \"session_cancellation\""
input session_cancellation_var_samp_order_by {
  id: order_by
  session_id: order_by
}

"order by variance() on columns of table \"session_cancellation\""
input session_cancellation_variance_order_by {
  id: order_by
  session_id: order_by
}

"order by aggregate values of table \"session_feedback\""
input session_feedback_aggregate_order_by {
  avg: session_feedback_avg_order_by
  count: order_by
  max: session_feedback_max_order_by
  min: session_feedback_min_order_by
  stddev: session_feedback_stddev_order_by
  stddev_pop: session_feedback_stddev_pop_order_by
  stddev_samp: session_feedback_stddev_samp_order_by
  sum: session_feedback_sum_order_by
  var_pop: session_feedback_var_pop_order_by
  var_samp: session_feedback_var_samp_order_by
  variance: session_feedback_variance_order_by
}

"input type for inserting array relation for remote table \"session_feedback\""
input session_feedback_arr_rel_insert_input {
  data: [session_feedback_insert_input!]!
  on_conflict: session_feedback_on_conflict
}

"order by avg() on columns of table \"session_feedback\""
input session_feedback_avg_order_by {
  id: order_by
  session_id: order_by
}

"Boolean expression to filter rows from the table \"session_feedback\". All fields are combined with a logical 'AND'."
input session_feedback_bool_exp {
  _and: [session_feedback_bool_exp]
  _not: session_feedback_bool_exp
  _or: [session_feedback_bool_exp]
  comment: String_comparison_exp
  helpful: Boolean_comparison_exp
  id: Int_comparison_exp
  session: session_bool_exp
  session_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"session_feedback\""
input session_feedback_inc_input {
  id: Int
  session_id: Int
}

"input type for inserting data into table \"session_feedback\""
input session_feedback_insert_input {
  comment: String
  helpful: Boolean
  id: Int
  session: session_obj_rel_insert_input
  session_id: Int
}

"order by max() on columns of table \"session_feedback\""
input session_feedback_max_order_by {
  comment: order_by
  id: order_by
  session_id: order_by
}

"order by min() on columns of table \"session_feedback\""
input session_feedback_min_order_by {
  comment: order_by
  id: order_by
  session_id: order_by
}

"input type for inserting object relation for remote table \"session_feedback\""
input session_feedback_obj_rel_insert_input {
  data: session_feedback_insert_input!
  on_conflict: session_feedback_on_conflict
}

"on conflict condition type for table \"session_feedback\""
input session_feedback_on_conflict {
  constraint: session_feedback_constraint!
  update_columns: [session_feedback_update_column!]!
  where: session_feedback_bool_exp
}

"ordering options when selecting data from \"session_feedback\""
input session_feedback_order_by {
  comment: order_by
  helpful: order_by
  id: order_by
  session: session_order_by
  session_id: order_by
}

"primary key columns input for table: \"session_feedback\""
input session_feedback_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"session_feedback\""
input session_feedback_set_input {
  comment: String
  helpful: Boolean
  id: Int
  session_id: Int
}

"order by stddev() on columns of table \"session_feedback\""
input session_feedback_stddev_order_by {
  id: order_by
  session_id: order_by
}

"order by stddev_pop() on columns of table \"session_feedback\""
input session_feedback_stddev_pop_order_by {
  id: order_by
  session_id: order_by
}

"order by stddev_samp() on columns of table \"session_feedback\""
input session_feedback_stddev_samp_order_by {
  id: order_by
  session_id: order_by
}

"order by sum() on columns of table \"session_feedback\""
input session_feedback_sum_order_by {
  id: order_by
  session_id: order_by
}

"order by var_pop() on columns of table \"session_feedback\""
input session_feedback_var_pop_order_by {
  id: order_by
  session_id: order_by
}

"order by var_samp() on columns of table \"session_feedback\""
input session_feedback_var_samp_order_by {
  id: order_by
  session_id: order_by
}

"order by variance() on columns of table \"session_feedback\""
input session_feedback_variance_order_by {
  id: order_by
  session_id: order_by
}

"input type for incrementing integer column in table \"session\""
input session_inc_input {
  counselor_enrollment_id: Int
  id: Int
  session_status_id: Int
  session_type_id: Int
  student_enrollment_id: Int
}

"input type for inserting data into table \"session\""
input session_insert_input {
  cancellation: session_cancellation_obj_rel_insert_input
  chat_channel_id: String
  chat_document_id: uuid
  cleanup_session: Boolean
  counselor: user_obj_rel_insert_input
  counselor_enrollment: counselor_enrollment_obj_rel_insert_input
  counselor_enrollment_id: Int
  counselor_id: uuid
  description: String
  end_date: timestamptz
  id: Int
  note_document_id: uuid
  payouts: payout_arr_rel_insert_input
  scheduled_end_date: timestamptz
  scheduled_start_date: timestamptz
  session_feedback: session_feedback_obj_rel_insert_input
  session_reminder_1m: Boolean
  session_reminder_30m: Boolean
  session_status: session_status_obj_rel_insert_input
  session_status_id: Int
  session_topics: session_topic_arr_rel_insert_input
  session_type: session_type_obj_rel_insert_input
  session_type_id: Int
  start_date: timestamptz
  student: user_obj_rel_insert_input
  student_enrollment: student_enrollment_obj_rel_insert_input
  student_enrollment_id: Int
  student_id: uuid
}

"order by max() on columns of table \"session\""
input session_max_order_by {
  chat_channel_id: order_by
  chat_document_id: order_by
  counselor_enrollment_id: order_by
  counselor_id: order_by
  description: order_by
  end_date: order_by
  id: order_by
  note_document_id: order_by
  scheduled_end_date: order_by
  scheduled_start_date: order_by
  session_status_id: order_by
  session_type_id: order_by
  start_date: order_by
  student_enrollment_id: order_by
  student_id: order_by
}

"order by min() on columns of table \"session\""
input session_min_order_by {
  chat_channel_id: order_by
  chat_document_id: order_by
  counselor_enrollment_id: order_by
  counselor_id: order_by
  description: order_by
  end_date: order_by
  id: order_by
  note_document_id: order_by
  scheduled_end_date: order_by
  scheduled_start_date: order_by
  session_status_id: order_by
  session_type_id: order_by
  start_date: order_by
  student_enrollment_id: order_by
  student_id: order_by
}

"input type for inserting object relation for remote table \"session\""
input session_obj_rel_insert_input {
  data: session_insert_input!
  on_conflict: session_on_conflict
}

"on conflict condition type for table \"session\""
input session_on_conflict {
  constraint: session_constraint!
  update_columns: [session_update_column!]!
  where: session_bool_exp
}

"ordering options when selecting data from \"session\""
input session_order_by {
  cancellation: session_cancellation_order_by
  chat_channel_id: order_by
  chat_document_id: order_by
  cleanup_session: order_by
  counselor: user_order_by
  counselor_enrollment: counselor_enrollment_order_by
  counselor_enrollment_id: order_by
  counselor_id: order_by
  description: order_by
  end_date: order_by
  id: order_by
  note_document_id: order_by
  payouts_aggregate: payout_aggregate_order_by
  scheduled_end_date: order_by
  scheduled_start_date: order_by
  session_feedback: session_feedback_order_by
  session_reminder_1m: order_by
  session_reminder_30m: order_by
  session_status: session_status_order_by
  session_status_id: order_by
  session_topics_aggregate: session_topic_aggregate_order_by
  session_type: session_type_order_by
  session_type_id: order_by
  start_date: order_by
  student: user_order_by
  student_enrollment: student_enrollment_order_by
  student_enrollment_id: order_by
  student_id: order_by
}

"primary key columns input for table: \"session\""
input session_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"session\""
input session_set_input {
  chat_channel_id: String
  chat_document_id: uuid
  cleanup_session: Boolean
  counselor_enrollment_id: Int
  counselor_id: uuid
  description: String
  end_date: timestamptz
  id: Int
  note_document_id: uuid
  scheduled_end_date: timestamptz
  scheduled_start_date: timestamptz
  session_reminder_1m: Boolean
  session_reminder_30m: Boolean
  session_status_id: Int
  session_type_id: Int
  start_date: timestamptz
  student_enrollment_id: Int
  student_id: uuid
}

"order by aggregate values of table \"session_status\""
input session_status_aggregate_order_by {
  avg: session_status_avg_order_by
  count: order_by
  max: session_status_max_order_by
  min: session_status_min_order_by
  stddev: session_status_stddev_order_by
  stddev_pop: session_status_stddev_pop_order_by
  stddev_samp: session_status_stddev_samp_order_by
  sum: session_status_sum_order_by
  var_pop: session_status_var_pop_order_by
  var_samp: session_status_var_samp_order_by
  variance: session_status_variance_order_by
}

"input type for inserting array relation for remote table \"session_status\""
input session_status_arr_rel_insert_input {
  data: [session_status_insert_input!]!
  on_conflict: session_status_on_conflict
}

"order by avg() on columns of table \"session_status\""
input session_status_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"session_status\". All fields are combined with a logical 'AND'."
input session_status_bool_exp {
  _and: [session_status_bool_exp]
  _not: session_status_bool_exp
  _or: [session_status_bool_exp]
  id: Int_comparison_exp
  session: session_bool_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"session_status\""
input session_status_inc_input {
  id: Int
}

"input type for inserting data into table \"session_status\""
input session_status_insert_input {
  id: Int
  session: session_obj_rel_insert_input
  value: String
}

"order by max() on columns of table \"session_status\""
input session_status_max_order_by {
  id: order_by
  value: order_by
}

"order by min() on columns of table \"session_status\""
input session_status_min_order_by {
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"session_status\""
input session_status_obj_rel_insert_input {
  data: session_status_insert_input!
  on_conflict: session_status_on_conflict
}

"on conflict condition type for table \"session_status\""
input session_status_on_conflict {
  constraint: session_status_constraint!
  update_columns: [session_status_update_column!]!
  where: session_status_bool_exp
}

"ordering options when selecting data from \"session_status\""
input session_status_order_by {
  id: order_by
  session: session_order_by
  value: order_by
}

"primary key columns input for table: \"session_status\""
input session_status_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"session_status\""
input session_status_set_input {
  id: Int
  value: String
}

"order by stddev() on columns of table \"session_status\""
input session_status_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"session_status\""
input session_status_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"session_status\""
input session_status_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"session_status\""
input session_status_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"session_status\""
input session_status_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"session_status\""
input session_status_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"session_status\""
input session_status_variance_order_by {
  id: order_by
}

"order by stddev() on columns of table \"session\""
input session_stddev_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  session_status_id: order_by
  session_type_id: order_by
  student_enrollment_id: order_by
}

"order by stddev_pop() on columns of table \"session\""
input session_stddev_pop_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  session_status_id: order_by
  session_type_id: order_by
  student_enrollment_id: order_by
}

"order by stddev_samp() on columns of table \"session\""
input session_stddev_samp_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  session_status_id: order_by
  session_type_id: order_by
  student_enrollment_id: order_by
}

"order by sum() on columns of table \"session\""
input session_sum_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  session_status_id: order_by
  session_type_id: order_by
  student_enrollment_id: order_by
}

"order by aggregate values of table \"session_topic\""
input session_topic_aggregate_order_by {
  avg: session_topic_avg_order_by
  count: order_by
  max: session_topic_max_order_by
  min: session_topic_min_order_by
  stddev: session_topic_stddev_order_by
  stddev_pop: session_topic_stddev_pop_order_by
  stddev_samp: session_topic_stddev_samp_order_by
  sum: session_topic_sum_order_by
  var_pop: session_topic_var_pop_order_by
  var_samp: session_topic_var_samp_order_by
  variance: session_topic_variance_order_by
}

"input type for inserting array relation for remote table \"session_topic\""
input session_topic_arr_rel_insert_input {
  data: [session_topic_insert_input!]!
  on_conflict: session_topic_on_conflict
}

"order by avg() on columns of table \"session_topic\""
input session_topic_avg_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"Boolean expression to filter rows from the table \"session_topic\". All fields are combined with a logical 'AND'."
input session_topic_bool_exp {
  _and: [session_topic_bool_exp]
  _not: session_topic_bool_exp
  _or: [session_topic_bool_exp]
  id: Int_comparison_exp
  session: session_bool_exp
  session_id: Int_comparison_exp
  topic: topic_bool_exp
  topic_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"session_topic\""
input session_topic_inc_input {
  id: Int
  session_id: Int
  topic_id: Int
}

"input type for inserting data into table \"session_topic\""
input session_topic_insert_input {
  id: Int
  session: session_obj_rel_insert_input
  session_id: Int
  topic: topic_obj_rel_insert_input
  topic_id: Int
}

"order by max() on columns of table \"session_topic\""
input session_topic_max_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"order by min() on columns of table \"session_topic\""
input session_topic_min_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"input type for inserting object relation for remote table \"session_topic\""
input session_topic_obj_rel_insert_input {
  data: session_topic_insert_input!
  on_conflict: session_topic_on_conflict
}

"on conflict condition type for table \"session_topic\""
input session_topic_on_conflict {
  constraint: session_topic_constraint!
  update_columns: [session_topic_update_column!]!
  where: session_topic_bool_exp
}

"ordering options when selecting data from \"session_topic\""
input session_topic_order_by {
  id: order_by
  session: session_order_by
  session_id: order_by
  topic: topic_order_by
  topic_id: order_by
}

"primary key columns input for table: \"session_topic\""
input session_topic_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"session_topic\""
input session_topic_set_input {
  id: Int
  session_id: Int
  topic_id: Int
}

"order by stddev() on columns of table \"session_topic\""
input session_topic_stddev_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"order by stddev_pop() on columns of table \"session_topic\""
input session_topic_stddev_pop_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"order by stddev_samp() on columns of table \"session_topic\""
input session_topic_stddev_samp_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"order by sum() on columns of table \"session_topic\""
input session_topic_sum_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"order by var_pop() on columns of table \"session_topic\""
input session_topic_var_pop_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"order by var_samp() on columns of table \"session_topic\""
input session_topic_var_samp_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"order by variance() on columns of table \"session_topic\""
input session_topic_variance_order_by {
  id: order_by
  session_id: order_by
  topic_id: order_by
}

"order by aggregate values of table \"session_type\""
input session_type_aggregate_order_by {
  avg: session_type_avg_order_by
  count: order_by
  max: session_type_max_order_by
  min: session_type_min_order_by
  stddev: session_type_stddev_order_by
  stddev_pop: session_type_stddev_pop_order_by
  stddev_samp: session_type_stddev_samp_order_by
  sum: session_type_sum_order_by
  var_pop: session_type_var_pop_order_by
  var_samp: session_type_var_samp_order_by
  variance: session_type_variance_order_by
}

"input type for inserting array relation for remote table \"session_type\""
input session_type_arr_rel_insert_input {
  data: [session_type_insert_input!]!
  on_conflict: session_type_on_conflict
}

"order by avg() on columns of table \"session_type\""
input session_type_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"session_type\". All fields are combined with a logical 'AND'."
input session_type_bool_exp {
  _and: [session_type_bool_exp]
  _not: session_type_bool_exp
  _or: [session_type_bool_exp]
  id: Int_comparison_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"session_type\""
input session_type_inc_input {
  id: Int
}

"input type for inserting data into table \"session_type\""
input session_type_insert_input {
  id: Int
  value: String
}

"order by max() on columns of table \"session_type\""
input session_type_max_order_by {
  id: order_by
  value: order_by
}

"order by min() on columns of table \"session_type\""
input session_type_min_order_by {
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"session_type\""
input session_type_obj_rel_insert_input {
  data: session_type_insert_input!
  on_conflict: session_type_on_conflict
}

"on conflict condition type for table \"session_type\""
input session_type_on_conflict {
  constraint: session_type_constraint!
  update_columns: [session_type_update_column!]!
  where: session_type_bool_exp
}

"ordering options when selecting data from \"session_type\""
input session_type_order_by {
  id: order_by
  value: order_by
}

"primary key columns input for table: \"session_type\""
input session_type_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"session_type\""
input session_type_set_input {
  id: Int
  value: String
}

"order by stddev() on columns of table \"session_type\""
input session_type_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"session_type\""
input session_type_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"session_type\""
input session_type_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"session_type\""
input session_type_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"session_type\""
input session_type_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"session_type\""
input session_type_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"session_type\""
input session_type_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"session\""
input session_var_pop_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  session_status_id: order_by
  session_type_id: order_by
  student_enrollment_id: order_by
}

"order by var_samp() on columns of table \"session\""
input session_var_samp_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  session_status_id: order_by
  session_type_id: order_by
  student_enrollment_id: order_by
}

"order by variance() on columns of table \"session\""
input session_variance_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  session_status_id: order_by
  session_type_id: order_by
  student_enrollment_id: order_by
}

input sessionsOlderThan_args {
  minutes: numeric
  status_id: numeric
}

"order by aggregate values of table \"sexuality\""
input sexuality_aggregate_order_by {
  avg: sexuality_avg_order_by
  count: order_by
  max: sexuality_max_order_by
  min: sexuality_min_order_by
  stddev: sexuality_stddev_order_by
  stddev_pop: sexuality_stddev_pop_order_by
  stddev_samp: sexuality_stddev_samp_order_by
  sum: sexuality_sum_order_by
  var_pop: sexuality_var_pop_order_by
  var_samp: sexuality_var_samp_order_by
  variance: sexuality_variance_order_by
}

"input type for inserting array relation for remote table \"sexuality\""
input sexuality_arr_rel_insert_input {
  data: [sexuality_insert_input!]!
  on_conflict: sexuality_on_conflict
}

"order by avg() on columns of table \"sexuality\""
input sexuality_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"sexuality\". All fields are combined with a logical 'AND'."
input sexuality_bool_exp {
  _and: [sexuality_bool_exp]
  _not: sexuality_bool_exp
  _or: [sexuality_bool_exp]
  id: Int_comparison_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"sexuality\""
input sexuality_inc_input {
  id: Int
}

"input type for inserting data into table \"sexuality\""
input sexuality_insert_input {
  id: Int
  value: String
}

"order by max() on columns of table \"sexuality\""
input sexuality_max_order_by {
  id: order_by
  value: order_by
}

"order by min() on columns of table \"sexuality\""
input sexuality_min_order_by {
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"sexuality\""
input sexuality_obj_rel_insert_input {
  data: sexuality_insert_input!
  on_conflict: sexuality_on_conflict
}

"on conflict condition type for table \"sexuality\""
input sexuality_on_conflict {
  constraint: sexuality_constraint!
  update_columns: [sexuality_update_column!]!
  where: sexuality_bool_exp
}

"ordering options when selecting data from \"sexuality\""
input sexuality_order_by {
  id: order_by
  value: order_by
}

"primary key columns input for table: \"sexuality\""
input sexuality_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"sexuality\""
input sexuality_set_input {
  id: Int
  value: String
}

"order by stddev() on columns of table \"sexuality\""
input sexuality_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"sexuality\""
input sexuality_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"sexuality\""
input sexuality_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"sexuality\""
input sexuality_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"sexuality\""
input sexuality_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"sexuality\""
input sexuality_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"sexuality\""
input sexuality_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"shift\""
input shift_aggregate_order_by {
  avg: shift_avg_order_by
  count: order_by
  max: shift_max_order_by
  min: shift_min_order_by
  stddev: shift_stddev_order_by
  stddev_pop: shift_stddev_pop_order_by
  stddev_samp: shift_stddev_samp_order_by
  sum: shift_sum_order_by
  var_pop: shift_var_pop_order_by
  var_samp: shift_var_samp_order_by
  variance: shift_variance_order_by
}

"input type for inserting array relation for remote table \"shift\""
input shift_arr_rel_insert_input {
  data: [shift_insert_input!]!
  on_conflict: shift_on_conflict
}

"order by avg() on columns of table \"shift\""
input shift_avg_order_by {
  capacity: order_by
  id: order_by
  state_id: order_by
}

"Boolean expression to filter rows from the table \"shift\". All fields are combined with a logical 'AND'."
input shift_bool_exp {
  _and: [shift_bool_exp]
  _not: shift_bool_exp
  _or: [shift_bool_exp]
  admin_id: uuid_comparison_exp
  capacity: Int_comparison_exp
  counselor_enrollment: counselor_enrollment_bool_exp
  created_date: timestamptz_comparison_exp
  end_date: timestamptz_comparison_exp
  id: Int_comparison_exp
  shift_states: shift_states_bool_exp
  start_date: timestamptz_comparison_exp
  state_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"shift\""
input shift_inc_input {
  capacity: Int
  id: Int
  state_id: Int
}

"input type for inserting data into table \"shift\""
input shift_insert_input {
  admin_id: uuid
  capacity: Int
  counselor_enrollment: counselor_enrollment_arr_rel_insert_input
  created_date: timestamptz
  end_date: timestamptz
  id: Int
  shift_states: shift_states_arr_rel_insert_input
  start_date: timestamptz
  state_id: Int
}

"order by max() on columns of table \"shift\""
input shift_max_order_by {
  admin_id: order_by
  capacity: order_by
  created_date: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  state_id: order_by
}

"order by min() on columns of table \"shift\""
input shift_min_order_by {
  admin_id: order_by
  capacity: order_by
  created_date: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  state_id: order_by
}

"input type for inserting object relation for remote table \"shift\""
input shift_obj_rel_insert_input {
  data: shift_insert_input!
  on_conflict: shift_on_conflict
}

"on conflict condition type for table \"shift\""
input shift_on_conflict {
  constraint: shift_constraint!
  update_columns: [shift_update_column!]!
  where: shift_bool_exp
}

"ordering options when selecting data from \"shift\""
input shift_order_by {
  admin_id: order_by
  capacity: order_by
  counselor_enrollment_aggregate: counselor_enrollment_aggregate_order_by
  created_date: order_by
  end_date: order_by
  id: order_by
  shift_states_aggregate: shift_states_aggregate_order_by
  start_date: order_by
  state_id: order_by
}

"primary key columns input for table: \"shift\""
input shift_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"shift\""
input shift_set_input {
  admin_id: uuid
  capacity: Int
  created_date: timestamptz
  end_date: timestamptz
  id: Int
  start_date: timestamptz
  state_id: Int
}

"order by aggregate values of table \"shift_states\""
input shift_states_aggregate_order_by {
  avg: shift_states_avg_order_by
  count: order_by
  max: shift_states_max_order_by
  min: shift_states_min_order_by
  stddev: shift_states_stddev_order_by
  stddev_pop: shift_states_stddev_pop_order_by
  stddev_samp: shift_states_stddev_samp_order_by
  sum: shift_states_sum_order_by
  var_pop: shift_states_var_pop_order_by
  var_samp: shift_states_var_samp_order_by
  variance: shift_states_variance_order_by
}

"input type for inserting array relation for remote table \"shift_states\""
input shift_states_arr_rel_insert_input {
  data: [shift_states_insert_input!]!
  on_conflict: shift_states_on_conflict
}

"order by avg() on columns of table \"shift_states\""
input shift_states_avg_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"Boolean expression to filter rows from the table \"shift_states\". All fields are combined with a logical 'AND'."
input shift_states_bool_exp {
  _and: [shift_states_bool_exp]
  _not: shift_states_bool_exp
  _or: [shift_states_bool_exp]
  capacity: numeric_comparison_exp
  counselor_enrollment: counselor_enrollment_bool_exp
  id: Int_comparison_exp
  shift: shift_bool_exp
  shift_id: Int_comparison_exp
  state: state_bool_exp
  state_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"shift_states\""
input shift_states_inc_input {
  capacity: numeric
  id: Int
  shift_id: Int
  state_id: Int
}

"input type for inserting data into table \"shift_states\""
input shift_states_insert_input {
  capacity: numeric
  counselor_enrollment: counselor_enrollment_arr_rel_insert_input
  id: Int
  shift: shift_obj_rel_insert_input
  shift_id: Int
  state: state_obj_rel_insert_input
  state_id: Int
}

"order by max() on columns of table \"shift_states\""
input shift_states_max_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"order by min() on columns of table \"shift_states\""
input shift_states_min_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"input type for inserting object relation for remote table \"shift_states\""
input shift_states_obj_rel_insert_input {
  data: shift_states_insert_input!
  on_conflict: shift_states_on_conflict
}

"on conflict condition type for table \"shift_states\""
input shift_states_on_conflict {
  constraint: shift_states_constraint!
  update_columns: [shift_states_update_column!]!
  where: shift_states_bool_exp
}

"ordering options when selecting data from \"shift_states\""
input shift_states_order_by {
  capacity: order_by
  counselor_enrollment_aggregate: counselor_enrollment_aggregate_order_by
  id: order_by
  shift: shift_order_by
  shift_id: order_by
  state: state_order_by
  state_id: order_by
}

"primary key columns input for table: \"shift_states\""
input shift_states_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"shift_states\""
input shift_states_set_input {
  capacity: numeric
  id: Int
  shift_id: Int
  state_id: Int
}

"order by stddev() on columns of table \"shift_states\""
input shift_states_stddev_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"order by stddev_pop() on columns of table \"shift_states\""
input shift_states_stddev_pop_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"order by stddev_samp() on columns of table \"shift_states\""
input shift_states_stddev_samp_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"order by sum() on columns of table \"shift_states\""
input shift_states_sum_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"order by var_pop() on columns of table \"shift_states\""
input shift_states_var_pop_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"order by var_samp() on columns of table \"shift_states\""
input shift_states_var_samp_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"order by variance() on columns of table \"shift_states\""
input shift_states_variance_order_by {
  capacity: order_by
  id: order_by
  shift_id: order_by
  state_id: order_by
}

"order by stddev() on columns of table \"shift\""
input shift_stddev_order_by {
  capacity: order_by
  id: order_by
  state_id: order_by
}

"order by stddev_pop() on columns of table \"shift\""
input shift_stddev_pop_order_by {
  capacity: order_by
  id: order_by
  state_id: order_by
}

"order by stddev_samp() on columns of table \"shift\""
input shift_stddev_samp_order_by {
  capacity: order_by
  id: order_by
  state_id: order_by
}

"order by sum() on columns of table \"shift\""
input shift_sum_order_by {
  capacity: order_by
  id: order_by
  state_id: order_by
}

"order by var_pop() on columns of table \"shift\""
input shift_var_pop_order_by {
  capacity: order_by
  id: order_by
  state_id: order_by
}

"order by var_samp() on columns of table \"shift\""
input shift_var_samp_order_by {
  capacity: order_by
  id: order_by
  state_id: order_by
}

"order by variance() on columns of table \"shift\""
input shift_variance_order_by {
  capacity: order_by
  id: order_by
  state_id: order_by
}

"order by aggregate values of table \"state\""
input state_aggregate_order_by {
  avg: state_avg_order_by
  count: order_by
  max: state_max_order_by
  min: state_min_order_by
  stddev: state_stddev_order_by
  stddev_pop: state_stddev_pop_order_by
  stddev_samp: state_stddev_samp_order_by
  sum: state_sum_order_by
  var_pop: state_var_pop_order_by
  var_samp: state_var_samp_order_by
  variance: state_variance_order_by
}

"input type for inserting array relation for remote table \"state\""
input state_arr_rel_insert_input {
  data: [state_insert_input!]!
  on_conflict: state_on_conflict
}

"order by avg() on columns of table \"state\""
input state_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"state\". All fields are combined with a logical 'AND'."
input state_bool_exp {
  _and: [state_bool_exp]
  _not: state_bool_exp
  _or: [state_bool_exp]
  abbreviation: String_comparison_exp
  id: Int_comparison_exp
  schools: school_bool_exp
  shifts_state: shift_states_bool_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"state\""
input state_inc_input {
  id: Int
}

"input type for inserting data into table \"state\""
input state_insert_input {
  abbreviation: String
  id: Int
  schools: school_arr_rel_insert_input
  shifts_state: shift_states_arr_rel_insert_input
  value: String
}

"order by max() on columns of table \"state\""
input state_max_order_by {
  abbreviation: order_by
  id: order_by
  value: order_by
}

"order by min() on columns of table \"state\""
input state_min_order_by {
  abbreviation: order_by
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"state\""
input state_obj_rel_insert_input {
  data: state_insert_input!
  on_conflict: state_on_conflict
}

"on conflict condition type for table \"state\""
input state_on_conflict {
  constraint: state_constraint!
  update_columns: [state_update_column!]!
  where: state_bool_exp
}

"ordering options when selecting data from \"state\""
input state_order_by {
  abbreviation: order_by
  id: order_by
  schools_aggregate: school_aggregate_order_by
  shifts_state_aggregate: shift_states_aggregate_order_by
  value: order_by
}

"primary key columns input for table: \"state\""
input state_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"state\""
input state_set_input {
  abbreviation: String
  id: Int
  value: String
}

"order by stddev() on columns of table \"state\""
input state_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"state\""
input state_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"state\""
input state_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"state\""
input state_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"state\""
input state_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"state\""
input state_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"state\""
input state_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"student_enrollment\""
input student_enrollment_aggregate_order_by {
  avg: student_enrollment_avg_order_by
  count: order_by
  max: student_enrollment_max_order_by
  min: student_enrollment_min_order_by
  stddev: student_enrollment_stddev_order_by
  stddev_pop: student_enrollment_stddev_pop_order_by
  stddev_samp: student_enrollment_stddev_samp_order_by
  sum: student_enrollment_sum_order_by
  var_pop: student_enrollment_var_pop_order_by
  var_samp: student_enrollment_var_samp_order_by
  variance: student_enrollment_variance_order_by
}

"input type for inserting array relation for remote table \"student_enrollment\""
input student_enrollment_arr_rel_insert_input {
  data: [student_enrollment_insert_input!]!
  on_conflict: student_enrollment_on_conflict
}

"order by avg() on columns of table \"student_enrollment\""
input student_enrollment_avg_order_by {
  counselor_enrollment_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"student_enrollment\". All fields are combined with a logical 'AND'."
input student_enrollment_bool_exp {
  _and: [student_enrollment_bool_exp]
  _not: student_enrollment_bool_exp
  _or: [student_enrollment_bool_exp]
  auto_assigned: Boolean_comparison_exp
  counselor_enrollment: counselor_enrollment_bool_exp
  counselor_enrollment_id: Int_comparison_exp
  id: Int_comparison_exp
  session: session_bool_exp
  student_id: uuid_comparison_exp
}

"input type for incrementing integer column in table \"student_enrollment\""
input student_enrollment_inc_input {
  counselor_enrollment_id: Int
  id: Int
}

"input type for inserting data into table \"student_enrollment\""
input student_enrollment_insert_input {
  auto_assigned: Boolean
  counselor_enrollment: counselor_enrollment_obj_rel_insert_input
  counselor_enrollment_id: Int
  id: Int
  session: session_obj_rel_insert_input
  student_id: uuid
}

"order by max() on columns of table \"student_enrollment\""
input student_enrollment_max_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  student_id: order_by
}

"order by min() on columns of table \"student_enrollment\""
input student_enrollment_min_order_by {
  counselor_enrollment_id: order_by
  id: order_by
  student_id: order_by
}

"input type for inserting object relation for remote table \"student_enrollment\""
input student_enrollment_obj_rel_insert_input {
  data: student_enrollment_insert_input!
  on_conflict: student_enrollment_on_conflict
}

"on conflict condition type for table \"student_enrollment\""
input student_enrollment_on_conflict {
  constraint: student_enrollment_constraint!
  update_columns: [student_enrollment_update_column!]!
  where: student_enrollment_bool_exp
}

"ordering options when selecting data from \"student_enrollment\""
input student_enrollment_order_by {
  auto_assigned: order_by
  counselor_enrollment: counselor_enrollment_order_by
  counselor_enrollment_id: order_by
  id: order_by
  session: session_order_by
  student_id: order_by
}

"primary key columns input for table: \"student_enrollment\""
input student_enrollment_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"student_enrollment\""
input student_enrollment_set_input {
  auto_assigned: Boolean
  counselor_enrollment_id: Int
  id: Int
  student_id: uuid
}

"order by stddev() on columns of table \"student_enrollment\""
input student_enrollment_stddev_order_by {
  counselor_enrollment_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"student_enrollment\""
input student_enrollment_stddev_pop_order_by {
  counselor_enrollment_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"student_enrollment\""
input student_enrollment_stddev_samp_order_by {
  counselor_enrollment_id: order_by
  id: order_by
}

"order by sum() on columns of table \"student_enrollment\""
input student_enrollment_sum_order_by {
  counselor_enrollment_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"student_enrollment\""
input student_enrollment_var_pop_order_by {
  counselor_enrollment_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"student_enrollment\""
input student_enrollment_var_samp_order_by {
  counselor_enrollment_id: order_by
  id: order_by
}

"order by variance() on columns of table \"student_enrollment\""
input student_enrollment_variance_order_by {
  counselor_enrollment_id: order_by
  id: order_by
}

"expression to compare columns of type timestamptz. All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"order by aggregate values of table \"topic\""
input topic_aggregate_order_by {
  avg: topic_avg_order_by
  count: order_by
  max: topic_max_order_by
  min: topic_min_order_by
  stddev: topic_stddev_order_by
  stddev_pop: topic_stddev_pop_order_by
  stddev_samp: topic_stddev_samp_order_by
  sum: topic_sum_order_by
  var_pop: topic_var_pop_order_by
  var_samp: topic_var_samp_order_by
  variance: topic_variance_order_by
}

"input type for inserting array relation for remote table \"topic\""
input topic_arr_rel_insert_input {
  data: [topic_insert_input!]!
  on_conflict: topic_on_conflict
}

"order by avg() on columns of table \"topic\""
input topic_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"topic\". All fields are combined with a logical 'AND'."
input topic_bool_exp {
  _and: [topic_bool_exp]
  _not: topic_bool_exp
  _or: [topic_bool_exp]
  description: String_comparison_exp
  id: Int_comparison_exp
  session_topic: session_topic_bool_exp
}

"input type for incrementing integer column in table \"topic\""
input topic_inc_input {
  id: Int
}

"input type for inserting data into table \"topic\""
input topic_insert_input {
  description: String
  id: Int
  session_topic: session_topic_arr_rel_insert_input
}

"order by max() on columns of table \"topic\""
input topic_max_order_by {
  description: order_by
  id: order_by
}

"order by min() on columns of table \"topic\""
input topic_min_order_by {
  description: order_by
  id: order_by
}

"input type for inserting object relation for remote table \"topic\""
input topic_obj_rel_insert_input {
  data: topic_insert_input!
  on_conflict: topic_on_conflict
}

"on conflict condition type for table \"topic\""
input topic_on_conflict {
  constraint: topic_constraint!
  update_columns: [topic_update_column!]!
  where: topic_bool_exp
}

"ordering options when selecting data from \"topic\""
input topic_order_by {
  description: order_by
  id: order_by
  session_topic_aggregate: session_topic_aggregate_order_by
}

"primary key columns input for table: \"topic\""
input topic_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"topic\""
input topic_set_input {
  description: String
  id: Int
}

"order by stddev() on columns of table \"topic\""
input topic_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"topic\""
input topic_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"topic\""
input topic_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"topic\""
input topic_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"topic\""
input topic_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"topic\""
input topic_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"topic\""
input topic_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"user\""
input user_aggregate_order_by {
  avg: user_avg_order_by
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
  stddev: user_stddev_order_by
  stddev_pop: user_stddev_pop_order_by
  stddev_samp: user_stddev_samp_order_by
  sum: user_sum_order_by
  var_pop: user_var_pop_order_by
  var_samp: user_var_samp_order_by
  variance: user_variance_order_by
}

"input type for inserting array relation for remote table \"user\""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  on_conflict: user_on_conflict
}

"order by avg() on columns of table \"user\""
input user_avg_order_by {
  school_id: order_by
  user_type_id: order_by
}

"Boolean expression to filter rows from the table \"user\". All fields are combined with a logical 'AND'."
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  counselor_enrollment: counselor_enrollment_bool_exp
  devices: device_bool_exp
  enabled: Boolean_comparison_exp
  group_id: uuid_comparison_exp
  id: uuid_comparison_exp
  identity: identity_bool_exp
  identity_id: String_comparison_exp
  last_login_date: timestamptz_comparison_exp
  onboarding_completed: Boolean_comparison_exp
  profile_document_id: uuid_comparison_exp
  school: school_bool_exp
  school_id: Int_comparison_exp
  stripe_user_id: String_comparison_exp
  student_enrollment: student_enrollment_bool_exp
  user_type: user_type_bool_exp
  user_type_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"user\""
input user_inc_input {
  school_id: Int
  user_type_id: Int
}

"input type for inserting data into table \"user\""
input user_insert_input {
  counselor_enrollment: counselor_enrollment_arr_rel_insert_input
  devices: device_arr_rel_insert_input
  enabled: Boolean
  group_id: uuid
  id: uuid
  identity: identity_obj_rel_insert_input
  identity_id: String
  last_login_date: timestamptz
  onboarding_completed: Boolean
  profile_document_id: uuid
  school: school_obj_rel_insert_input
  school_id: Int
  stripe_user_id: String
  student_enrollment: student_enrollment_arr_rel_insert_input
  user_type: user_type_obj_rel_insert_input
  user_type_id: Int
}

"order by max() on columns of table \"user\""
input user_max_order_by {
  group_id: order_by
  id: order_by
  identity_id: order_by
  last_login_date: order_by
  profile_document_id: order_by
  school_id: order_by
  stripe_user_id: order_by
  user_type_id: order_by
}

"order by min() on columns of table \"user\""
input user_min_order_by {
  group_id: order_by
  id: order_by
  identity_id: order_by
  last_login_date: order_by
  profile_document_id: order_by
  school_id: order_by
  stripe_user_id: order_by
  user_type_id: order_by
}

"input type for inserting object relation for remote table \"user\""
input user_obj_rel_insert_input {
  data: user_insert_input!
  on_conflict: user_on_conflict
}

"on conflict condition type for table \"user\""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

"ordering options when selecting data from \"user\""
input user_order_by {
  counselor_enrollment_aggregate: counselor_enrollment_aggregate_order_by
  devices_aggregate: device_aggregate_order_by
  enabled: order_by
  group_id: order_by
  id: order_by
  identity: identity_order_by
  identity_id: order_by
  last_login_date: order_by
  onboarding_completed: order_by
  profile_document_id: order_by
  school: school_order_by
  school_id: order_by
  stripe_user_id: order_by
  student_enrollment_aggregate: student_enrollment_aggregate_order_by
  user_type: user_type_order_by
  user_type_id: order_by
}

"primary key columns input for table: \"user\""
input user_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"user\""
input user_set_input {
  enabled: Boolean
  group_id: uuid
  id: uuid
  identity_id: String
  last_login_date: timestamptz
  onboarding_completed: Boolean
  profile_document_id: uuid
  school_id: Int
  stripe_user_id: String
  user_type_id: Int
}

"order by stddev() on columns of table \"user\""
input user_stddev_order_by {
  school_id: order_by
  user_type_id: order_by
}

"order by stddev_pop() on columns of table \"user\""
input user_stddev_pop_order_by {
  school_id: order_by
  user_type_id: order_by
}

"order by stddev_samp() on columns of table \"user\""
input user_stddev_samp_order_by {
  school_id: order_by
  user_type_id: order_by
}

"order by sum() on columns of table \"user\""
input user_sum_order_by {
  school_id: order_by
  user_type_id: order_by
}

"order by aggregate values of table \"user_type\""
input user_type_aggregate_order_by {
  avg: user_type_avg_order_by
  count: order_by
  max: user_type_max_order_by
  min: user_type_min_order_by
  stddev: user_type_stddev_order_by
  stddev_pop: user_type_stddev_pop_order_by
  stddev_samp: user_type_stddev_samp_order_by
  sum: user_type_sum_order_by
  var_pop: user_type_var_pop_order_by
  var_samp: user_type_var_samp_order_by
  variance: user_type_variance_order_by
}

"input type for inserting array relation for remote table \"user_type\""
input user_type_arr_rel_insert_input {
  data: [user_type_insert_input!]!
  on_conflict: user_type_on_conflict
}

"order by avg() on columns of table \"user_type\""
input user_type_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"user_type\". All fields are combined with a logical 'AND'."
input user_type_bool_exp {
  _and: [user_type_bool_exp]
  _not: user_type_bool_exp
  _or: [user_type_bool_exp]
  id: Int_comparison_exp
  value: String_comparison_exp
}

"input type for incrementing integer column in table \"user_type\""
input user_type_inc_input {
  id: Int
}

"input type for inserting data into table \"user_type\""
input user_type_insert_input {
  id: Int
  value: String
}

"order by max() on columns of table \"user_type\""
input user_type_max_order_by {
  id: order_by
  value: order_by
}

"order by min() on columns of table \"user_type\""
input user_type_min_order_by {
  id: order_by
  value: order_by
}

"input type for inserting object relation for remote table \"user_type\""
input user_type_obj_rel_insert_input {
  data: user_type_insert_input!
  on_conflict: user_type_on_conflict
}

"on conflict condition type for table \"user_type\""
input user_type_on_conflict {
  constraint: user_type_constraint!
  update_columns: [user_type_update_column!]!
  where: user_type_bool_exp
}

"ordering options when selecting data from \"user_type\""
input user_type_order_by {
  id: order_by
  value: order_by
}

"primary key columns input for table: \"user_type\""
input user_type_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"user_type\""
input user_type_set_input {
  id: Int
  value: String
}

"order by stddev() on columns of table \"user_type\""
input user_type_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"user_type\""
input user_type_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"user_type\""
input user_type_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"user_type\""
input user_type_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"user_type\""
input user_type_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"user_type\""
input user_type_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"user_type\""
input user_type_variance_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"user\""
input user_var_pop_order_by {
  school_id: order_by
  user_type_id: order_by
}

"order by var_samp() on columns of table \"user\""
input user_var_samp_order_by {
  school_id: order_by
  user_type_id: order_by
}

"order by variance() on columns of table \"user\""
input user_variance_order_by {
  school_id: order_by
  user_type_id: order_by
}

"expression to compare columns of type uuid. All fields are combined with logical 'AND'."
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}


scalar numeric

scalar timestamptz

scalar uuid
